(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{395:function(t,a,e){t.exports=e.p+"assets/img/flowchart-2x.5df01602.png"},396:function(t,a,e){t.exports=e.p+"assets/img/11add66dba39980d3e8333f8a746caa2.a359dc1f.png"},509:function(t,a,e){"use strict";e.r(a);var s=e(12),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"è½¬è½½-æ³›å‹å’Œå…ƒç¼–ç¨‹çš„æ¨¡å‹-java-go-rust-swift-dç­‰"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#è½¬è½½-æ³›å‹å’Œå…ƒç¼–ç¨‹çš„æ¨¡å‹-java-go-rust-swift-dç­‰"}},[t._v("#")]),t._v(" è½¬è½½ï¼šæ³›å‹å’Œå…ƒç¼–ç¨‹çš„æ¨¡å‹ï¼šJava, Go, Rust, Swift, Dç­‰")]),t._v(" "),s("p",[t._v("è¿™ç¯‡æ–‡ç« æœ€å¼€å§‹æ˜¯åœ¨å…¬ä¼—å·ä¸Šè¯»åˆ°çš„ï¼Œè¯‘è€…åœ¨"),s("a",{attrs:{href:"https://blog.csdn.net/weixin_45583158/article/details/109664612",target:"_blank",rel:"noopener noreferrer"}},[s("em",[t._v("æŸåšå®¢ç½‘ç«™")]),t._v("ä¸Šä¹Ÿå‘äº†"),s("OutboundLink")],1),t._v("ã€‚è‹±æ–‡åŸæ–‡æ˜¯ "),s("a",{attrs:{href:"https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Models of Generics and Metaprogramming: Go, Rust, Swift, D and More"),s("OutboundLink")],1),t._v(" ã€‚åºŸè¯ä¸å¤šè¯´ï¼Œä¸‹é¢å¼€å§‹ç²˜è´´æ­£æ–‡è¿‡æ¥å­˜æ¡£ï¼ˆè‡³äºä¸ºä»€ä¹ˆç²˜è´´è‹±æ–‡åŸæ–‡ï¼Œå› ä¸ºå…¬ä¼—å·å’Œ"),s("em",[t._v("æŸåšå®¢ç½‘ç«™")]),t._v("å¤åˆ¶éƒ½ä¸èƒ½ç›´æ¥ç²˜è´´è¿‡æ¥ markdownï¼Œæ ¼å¼éƒ½ä¹±äº† ğŸ˜ ã€‚æ—¢ç„¶æ˜¯è½¬è½½å˜›ï¼Œå°±æ‡’ä¸€ç‚¹äº†ã€‚")]),t._v(" "),s("p",[t._v("In some domains of programming itâ€™s common to want to write a data structure or algorithm that can work with elements of many different types, such as a generic list or a sorting algorithm that only needs a comparison function. Different programming languages have come up with all sorts of solutions to this problem: From just pointing people to existing general features that can be useful for the purpose (e.g C, Go) to generics systems so powerful they become Turing-complete (e.g. "),s("a",{attrs:{href:"https://sdleffler.github.io/RustTypeSystemTuringComplete/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Rust"),s("OutboundLink")],1),t._v(", "),s("a",{attrs:{href:"http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++"),s("OutboundLink")],1),t._v("). In this post Iâ€™m going to take you on a tour of the generics systems in many different languages and how they are implemented. Iâ€™ll start from how languages without a special generics system like C solve the problem and then Iâ€™ll show how gradually adding extensions in different directions leads to the systems found in other languages.")]),t._v(" "),s("p",[t._v("One reason I think generics are an interesting case is that theyâ€™re a simple case of the general problem of metaprogramming: writing programs that can generate classes of other programs. As evidence Iâ€™ll describe how three different fully general metaprogramming methods can be seen as extensions from different directions in the space of generics systems: dynamic languages like Python, procedural macro systems like "),s("a",{attrs:{href:"https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial",target:"_blank",rel:"noopener noreferrer"}},[t._v("Template Haskell"),s("OutboundLink")],1),t._v(", and staged compilation like "),s("a",{attrs:{href:"https://ziglang.org/#Generic-data-structures-and-functions",target:"_blank",rel:"noopener noreferrer"}},[t._v("Zig"),s("OutboundLink")],1),t._v(" and "),s("a",{attrs:{href:"http://terralang.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Terra"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"overview"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" Overview")]),t._v(" "),s("p",[t._v("I made a flow chart of all the systems I discuss to give you an overview of what this post will contain and how everything fits together:")]),t._v(" "),s("p",[s("img",{attrs:{src:e(395),alt:"Timing"}})]),t._v(" "),s("h2",{attrs:{id:"the-basic-ideas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-basic-ideas"}},[t._v("#")]),t._v(" The basic ideas")]),t._v(" "),s("p",[t._v("Letâ€™s say weâ€™re programming in a language without a generics system and we want to make a generic stack data structure which works for any data type. The problem is that each function and type definition we write only works for data thatâ€™s the same size, is copied the same way, and generally acts the same way.")]),t._v(" "),s("p",[t._v("Two ideas for how to get around this are to find a way to make all data types act the same way in our data structure, or to make multiple copies of our data structure with slight tweaks to deal with each data type the correct way. These two ideas form the basis of the two major classes of solutions to generics: â€œboxingâ€ and â€œmonomorphizationâ€.")]),t._v(" "),s("p",[t._v("Boxing is where we put everything in uniform â€œboxesâ€ so that they all act the same way. This is usually done by allocating things on the heap and just putting pointers in the data structure. We can make pointers to all different types act the same way so that the same code can deal with all data types! However this can come at the cost of extra memory allocation, dynamic lookups and cache misses. In C this corresponds to making your data structure store "),s("code",[t._v("void*")]),t._v(" pointers and just casting your data to and from "),s("code",[t._v("void*")]),t._v(" (allocating on the heap if the data isnâ€™t already on the heap).")]),t._v(" "),s("p",[t._v("Monomorphization is where we copy the code multiple times for the different types of data we want to store. This way each instance of the code can directly use the size and methods of the data it is working with, without any dynamic lookups. This produces the fastest possible code, but comes at the cost of bloat in code size and compile times as the same code with minor tweaks is compiled many times. In C this corresponds to "),s("a",{attrs:{href:"https://www.cs.grinnell.edu/~rebelsky/musings/cnix-macros-generics",target:"_blank",rel:"noopener noreferrer"}},[t._v("defining your entire data structure in a macro"),s("OutboundLink")],1),t._v(" and calling it for each type you want to use it with.")]),t._v(" "),s("p",[t._v("Overall the tradeoff is basically that boxing leads to better compile times but can hurt runtime performance, whereas monomorphization will generate the fastest code but takes extra time to compile and optimize all the different generated instances. They also differ in how they can be extended: Extensions to boxing allow more dynamic behavior at runtime, while monomorphization is more flexible with how different instances of generic code can differ. Itâ€™s also worth noting that in some larger programs the performance advantage of monomorphization might be canceled out by the additional instruction cache misses from all the extra generated code.")]),t._v(" "),s("p",[t._v("Each of these schools of generics has many directions it can be extended in to add additional power or safety, and different languages have taken them in very interesting directions. Some languages like Rust and C# even provide both options!")]),t._v(" "),s("h2",{attrs:{id:"boxing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#boxing"}},[t._v("#")]),t._v(" Boxing")]),t._v(" "),s("p",[t._v("Letâ€™s start with an example of the basic boxing approach in Go:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Stack "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  this"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Pop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" this"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  this"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" this"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("this"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Example languages that use basic boxing: C ("),s("code",[t._v("void*")]),t._v("), Go ("),s("code",[t._v("interface{}")]),t._v("), pre-generics Java ("),s("code",[t._v("Object")]),t._v("), pre-generics Objective-C ("),s("code",[t._v("id")]),t._v(")")]),t._v(" "),s("h2",{attrs:{id:"type-erased-boxed-generics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#type-erased-boxed-generics"}},[t._v("#")]),t._v(" Type-erased boxed generics")]),t._v(" "),s("p",[t._v("Hereâ€™s some problems with the basic boxing approach:")]),t._v(" "),s("ul",[s("li",[t._v("Depending on the language we often need to cast values to and from the correct type every time we read or write to the data structure.")]),t._v(" "),s("li",[t._v("Nothing stops us from putting elements of different types into the structure, which could allow bugs that manifest as runtime crashes.")])]),t._v(" "),s("p",[t._v("A solution to both of these problems is to add generics functionality to the type system, while still using the basic boxing method exactly as before at runtime. This approach is often called type erasure, because the types in the generics system are â€œerasedâ€ and all become the same type (like "),s("code",[t._v("Object")]),t._v(") under the hood.")]),t._v(" "),s("p",[t._v("Java and Objective-C both started out with basic boxing, and later added language features for generics with type erasure, even using the exact same collection types as before for compatibility, but with optional generic type parameters. See the following example from the "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Generics_in_Java",target:"_blank",rel:"noopener noreferrer"}},[t._v("Wikipedia article on Java Generics"),s("OutboundLink")],1),t._v(":")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),t._v(" v "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// A String that cannot be cast to an Integer")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Run time error")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" v "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// (type error) compilation-time error")]),t._v("\n")])])]),s("h3",{attrs:{id:"inferred-boxed-generics-with-a-uniform-representation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#inferred-boxed-generics-with-a-uniform-representation"}},[t._v("#")]),t._v(" Inferred boxed generics with a uniform representation")]),t._v(" "),s("p",[t._v("OCaml takes this idea even further with a uniform representation where there are no primitive types that require an additional boxing allocation (like "),s("code",[t._v("int")]),t._v(" needing to be turned into an "),s("code",[t._v("Integer")]),t._v(" to go in an "),s("code",[t._v("ArrayList")]),t._v(" in Java), because everything is either already boxed or represented by a pointer-sized integer, so everything is one machine word. However when the garbage collector looks at data stored in generic structures it needs to tell pointers from integers, so integers are tagged using a 1 bit in a place where valid aligned pointers never have a 1 bit, leaving only 31 or 63 bits of range.")]),t._v(" "),s("p",[t._v("OCaml also has a type inference system so you can write a function and the compiler will infer the most generic type possible if you donâ€™t annotate it, which can lead to functions that look like a dynamically typed language:")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" first "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("head "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("(* inferred type: 'a list -> 'a *)")]),t._v("\n")])])]),s("p",[t._v("The inferred type is read as â€œa function from a list of elements of type "),s("code",[t._v("'a")]),t._v(" to something of type "),s("code",[t._v("'a")]),t._v("â€. Which encodes the relation that the return type is the same as the list type but can be any type.")]),t._v(" "),s("h2",{attrs:{id:"interfaces"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interfaces"}},[t._v("#")]),t._v(" Interfaces")]),t._v(" "),s("p",[t._v("A different limitation in the basic boxing approach is that the boxed types are "),s("em",[t._v("completely")]),t._v(" opaque. This is fine for data structures like a stack, but things like a generic sorting function need some extra functionality, like a type-specific comparison function. Thereâ€™s a number of different ways of both implementing this at runtime and exposing this in the language, which are technically different axes and you can "),s("a",{attrs:{href:"http://okmij.org/ftp/Computation/typeclass.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("implement the same language using multiple of these approaches"),s("OutboundLink")],1),t._v(". However, it seems like different language features mostly lend themselves towards being implemented a certain way, and then language extensions take advantage of the strengths of the chosen implementation. This means thereâ€™s mostly two families of languages based around the different runtime approaches: vtables and dictionary passing.")]),t._v(" "),s("h3",{attrs:{id:"interface-vtables"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interface-vtables"}},[t._v("#")]),t._v(" Interface vtables")]),t._v(" "),s("p",[t._v("If we want to expose type-specific functions while sticking with the boxing strategy of a uniform way of working with everything, we can just make sure that thereâ€™s a uniform way to find the type-specific function we want from an object. This approach is called using â€œvtablesâ€ (shortened from â€œvirtual method tablesâ€ but nobody uses the full name) and how it is implemented is that at offset zero in every object in the generic structure is a pointer to some tables of function pointers with a consistent layout. These tables allow the generic code to look up a pointer to the type-specific functions in the same way for every type by indexing certain pointers at fixed offsets.")]),t._v(" "),s("p",[t._v("è¯‘è€…æ³¨ï¼Œå›¾ç¤ºå¦‚ä¸‹ï¼š")]),t._v(" "),s("p",[s("img",{attrs:{src:e(396),alt:"img"}})]),t._v(" "),s("p",[t._v("This is how "),s("code",[t._v("interface")]),t._v(" types are implemented in Go and "),s("code",[t._v("dyn")]),t._v(" "),s("code",[t._v("trait")]),t._v(" objects are implemented in Rust. When you cast a type to an interface type for something it implements, it creates a wrapper that contains a pointer to the original object and a pointer to a vtable of the type-specific functions for that interface. However this requires an extra layer of pointer indirection and a different layout, which is why sorting in Go uses "),s("a",{attrs:{href:"https://golang.org/pkg/sort/#Interface",target:"_blank",rel:"noopener noreferrer"}},[t._v("an interface for the container with a Swap method"),s("OutboundLink")],1),t._v(" instead of taking a slice of a "),s("code",[t._v("Comparable")]),t._v(" interface, because it would require allocating an entire new slice of the interface types and then it would only sort that and not the original slice!")]),t._v(" "),s("p",[t._v("è¯‘è€…æ³¨ï¼š\nGo è¯­è¨€å¯¹sliceè¿›è¡Œæ’åºï¼Œéœ€è¦åœ¨sliceï¼ˆåˆ‡ç‰‡ï¼‰ä¸Šå®ç°Sort.Interfaceæ¥å£ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Interface "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Len ä¸ºé›†åˆå†…å…ƒç´ çš„æ€»æ•°")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Less")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),t._v("ã€€"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//å¦‚æœindexä¸ºiçš„å…ƒç´ å°äºindexä¸ºjçš„å…ƒç´ ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Swap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Swap äº¤æ¢ç´¢å¼•ä¸º i å’Œ j çš„å…ƒç´ ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("ä½¿ç”¨æ–¹å¼ï¼š")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"fmt"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sort"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//å®šä¹‰interface{},å¹¶å®ç°sort.Interfaceæ¥å£çš„ä¸‰ä¸ªæ–¹æ³•")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" IntSlice "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c IntSlice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c IntSlice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Swap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c IntSlice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Less")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" IntSlice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("float64")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5.3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("IsSorted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//false")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("IsSorted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Float64sAreSorted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Float64s")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("IntsAreSorted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        sort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Ints")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//[1 2 3 5 7]")]),t._v("\n    fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//[1.1 2.3 3.4 5.3]")]),t._v("\n    fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [1 2 3 4 5]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("å¯¹äºJavaæ¥è¯´ï¼Œå¯¹æ•°ç»„æ’åºéœ€è¦åœ¨æ•°ç»„/é›†åˆå…ƒç´ ä¸Šå®ç°Comparable æ¥å£ï¼Œä»£ç å¦‚ä¸‹ï¼š")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Simpson")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Comparable")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Simpson")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Simpson")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareTo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Simpson")]),t._v(" simpson"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareTo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("simpson"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpsonSorting")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" sortingWithList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpsonCharacter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" simpsons "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpsonCharacter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Homer "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpsonCharacter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Marge "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpsonCharacter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Bart "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpsonCharacter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Lisa "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collections")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collections")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        simpsons"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"object-oriented-programming"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-oriented-programming"}},[t._v("#")]),t._v(" Object-oriented programming")]),t._v(" "),s("p",[t._v("Object oriented programming is a language feature that makes good use of the power of vtables. Instead of having separate interface objects that contain the vtables, object-oriented languages like Java just have a vtable pointer at the start of every object. Java-like languages have a system of inheritance and interfaces that can be implemented entirely with these object vtables.")]),t._v(" "),s("p",[t._v("As well as providing additional features, embedding vtables in every object also solves the earlier problem of needing to construct new interface types with indirection. Unlike "),s("code",[t._v("Go")]),t._v(", in Java "),s("a",{attrs:{href:"https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(java.lang.Object%5B%5D)",target:"_blank",rel:"noopener noreferrer"}},[t._v("the sorting function"),s("OutboundLink")],1),t._v(" can just use the "),s("code",[t._v("Comparable")]),t._v(" interface on types that implement it.")]),t._v(" "),s("h3",{attrs:{id:"reflection"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reflection"}},[t._v("#")]),t._v(" Reflection")]),t._v(" "),s("p",[t._v("Once you have vtables, itâ€™s not too difficult to have the compiler also generate tables of other type information like field names, types and locations. This allows accessing all the data in a type with the same code that can inspect all the data in any other type. This can be used to add a â€œreflectionâ€ feature to your language which can be used to implement things like serialization and pretty printing for arbitrary types. As an extension of the boxing paradigm it has the same tradeoff that it only requires one copy of the code but requires a lot of slow dynamic lookups, which can lead to slow serialization performance.")]),t._v(" "),s("p",[t._v("Examples of languages with reflection features they use for serialization and other things include Java, C# and Go.")]),t._v(" "),s("h3",{attrs:{id:"dynamically-typed-languages"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dynamically-typed-languages"}},[t._v("#")]),t._v(" Dynamically typed languages")]),t._v(" "),s("p",[t._v("Reflection is very powerful and can do a lot of different metaprogramming tasks, but one thing it canâ€™t do is create new types or edit the type information of existing values. If we add the ability to do this, as well as make the default access and modification syntaxes go through reflection, we end up with dynamically typed languages! The incredibly flexibility to do metaprogramming in languages like Python and Ruby comes from effectively super-powered reflection systems that are used for everything.")]),t._v(" "),s("p",[t._v("â€œBut Tristan, thatâ€™s not how dynamic languages work, they just implement everything with hash tables!â€ you may say. Well, hash tables are just a good data structure for implementing editable type information tables! Also, thatâ€™s just how some interpreters like CPython do things. If you look at how a high performance JIT like V8 implements things, "),s("a",{attrs:{href:"https://v8.dev/blog/fast-properties",target:"_blank",rel:"noopener noreferrer"}},[t._v("it looks a lot like vtables and reflection info"),s("OutboundLink")],1),t._v("! V8â€™s hidden classes (vtables and reflection info) and object layout are similar to what you might see in a Java VM, just with the capability for objects to change to a new vtable at runtime. This is not a coincidence because nothing is ever a coincidence: The person "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Chrome_V8",target:"_blank",rel:"noopener noreferrer"}},[t._v("listed on Wikipedia as the creator of V8"),s("OutboundLink")],1),t._v(" previously "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Lars_Bak_(computer_programmer)",target:"_blank",rel:"noopener noreferrer"}},[t._v("worked on a high-performance Java VM"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"dictionary-passing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dictionary-passing"}},[t._v("#")]),t._v(" Dictionary Passing")]),t._v(" "),s("p",[t._v("Another way of implementing dynamic interfaces than associating vtables with objects is to pass a table of the required function pointers along to generic functions that need them. This approach is in a way similar to constructing Go-style interface objects at the call site, just that the table is passed as a hidden argument instead of packaged into a bundle as one of the existing arguments.")]),t._v(" "),s("p",[t._v("This approach is used by "),s("a",{attrs:{href:"http://okmij.org/ftp/Computation/typeclass.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Haskell type classes"),s("OutboundLink")],1),t._v(" although GHC has the ability to do a kind of monomorphization as an optimization through inlining and specialization. Dictionary passing is also used by OCaml with an explicit argument in the form of "),s("a",{attrs:{href:"https://v1.realworldocaml.org/v1/en/html/first-class-modules.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("first class modules"),s("OutboundLink")],1),t._v(", but thereâ€™s a proposal to "),s("a",{attrs:{href:"https://tycon.github.io/modular-implicits.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("add a mechanism to make the parameter implicit"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"swift-witness-tables"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#swift-witness-tables"}},[t._v("#")]),t._v(" Swift Witness Tables")]),t._v(" "),s("p",[t._v("Swift makes the interesting realization that by using dictionary passing and also putting the size of types and how to move, copy and free them into the tables, they can provide all the information required to work with any type in a uniform way without boxing them. This way Swift can implement generics "),s("a",{attrs:{href:"https://www.reddit.com/r/rust/comments/7gkiie/implementing_swift_generics_video/",target:"_blank",rel:"noopener noreferrer"}},[t._v("without monomorphization and without allocating everything into a uniform representation"),s("OutboundLink")],1),t._v("! They still pay the cost of all the dynamic lookups that all boxing-family implementations pay, but they save on the allocation, memory and cache-incoherency costs. The Swift compiler also has the ability to specialize (monomorphize) and inline generics within a module and across modules with functions "),s("a",{attrs:{href:"https://github.com/apple/swift-evolution/blob/master/proposals/0193-cross-module-inlining-and-specialization.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("annotated "),s("code",[t._v("@inlinable")]),s("OutboundLink")],1),t._v(" to avoid these costs if it wants to, presumably using heuristics about how much it would bloat the code.")]),t._v(" "),s("p",[t._v("This functionality also explains how Swift can "),s("a",{attrs:{href:"https://github.com/apple/swift-evolution/blob/master/proposals/0260-library-evolution.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("implement ABI stability"),s("OutboundLink")],1),t._v(" in a way that allows adding and rearranging fields in "),s("code",[t._v("struct")]),t._v("s, although they provide a "),s("code",[t._v("@frozen")]),t._v(" attribute to opt out of dynamic lookups for performance reasons.")]),t._v(" "),s("h3",{attrs:{id:"intensional-type-analysis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#intensional-type-analysis"}},[t._v("#")]),t._v(" Intensional Type Analysis")]),t._v(" "),s("p",[t._v("One more way to implement interfaces for your boxed types is to add a type ID in a fixed part of the object like where a vtable pointer would go, then generate functions for each interface method that effectively have a big "),s("code",[t._v("switch")]),t._v(" statement over all the types that implement that interface method and dispatch to the correct type-specific method.")]),t._v(" "),s("p",[t._v("Iâ€™m not aware of any languages that use this technique, but C++ compilers and Java VMs do something similar to this when they use profile-guided optimization to learn that a certain generic call site mostly acts on objects of certain types. Theyâ€™ll replace the call site with a check for each common type and then a static dispatch for that common type, with the usual dynamic dispatch as a fallback case. This way the branch predictor can predict the common case branch will be taken and continue dispatching instructions through the static call.")]),t._v(" "),s("h2",{attrs:{id:"monomorphization"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#monomorphization"}},[t._v("#")]),t._v(" Monomorphization")]),t._v(" "),s("p",[t._v("Now, the alternative approach to boxing is monomorphization. In the monomorphization approach we need to find some way to output multiple versions of our code for each type we want to use it with. Compilers have multiple phases of representations that the code passes through as it is compiled, and we theoretically can do the copying at any of these stages.")]),t._v(" "),s("h3",{attrs:{id:"generating-source-code"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generating-source-code"}},[t._v("#")]),t._v(" Generating source code")]),t._v(" "),s("p",[t._v("The simplest approach to monomorphization is to do the copying at the stage of the first representation: source code! This way the compiler doesnâ€™t even have to have generics support in it, and this is what users of languages like C and Go, where the compiler doesnâ€™t support generics, sometimes do.")]),t._v(" "),s("p",[t._v("In C you can use the preprocessor and define your data structure in a macro or a header that you include multiple times with different "),s("code",[t._v("#define")]),t._v("s. In Go there are scripts like "),s("a",{attrs:{href:"https://github.com/cheekybits/genny",target:"_blank",rel:"noopener noreferrer"}},[t._v("genny"),s("OutboundLink")],1),t._v(" that make this code generation process easy.")]),t._v(" "),s("p",[t._v("The downside of this is that duplicating source code can have a lot of warts and edge cases to look out for depending on the language, and also gives the compiler lots of extra work to do parsing and type checking basically the same code many times. Again depending on language and tools this methodâ€™s generics can be ugly to write and use, like how if you write one inside a C macro every line has to end with a backslash and all type and function names need to have the type name manually concatenated onto their identifiers to avoid collisions.")]),t._v(" "),s("h3",{attrs:{id:"d-string-mixins"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#d-string-mixins"}},[t._v("#")]),t._v(" D string mixins")]),t._v(" "),s("p",[t._v("Code generation does have something going for it though, which is that you can generate the code using a fully powered programming language, and also it uses a representation that the user already knows.")]),t._v(" "),s("p",[t._v("Some languages that implement generics in some other way also include a clean way of doing code generation to address more general metaprogramming use cases not covered by their generics system, like serialization. The clearest example of this is Dâ€™s "),s("a",{attrs:{href:"https://dlang.org/articles/mixin.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("string mixins"),s("OutboundLink")],1),t._v(" which enable generating D code as strings using the full power of D during the middle of a compile.")]),t._v(" "),s("h3",{attrs:{id:"rust-procedural-macros"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-procedural-macros"}},[t._v("#")]),t._v(" Rust procedural macros")]),t._v(" "),s("p",[t._v("A similar example but with a representation only one step into the compiler is "),s("a",{attrs:{href:"https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Rustâ€™s procedural macros"),s("OutboundLink")],1),t._v(", which take token streams as input and output token streams, while providing utilities to convert token streams to and from strings. The advantage of this approach is that token streams can preserve source code location information. A macro can directly paste code the user wrote from input to output as tokens, then if the userâ€™s code causes a compiler error in the macro output the error message the compiler prints will correctly point to the file, line and columns of the broken part of the userâ€™s code, but if the macro generates broken code the error message will point to the macro invocation. For example if you use "),s("a",{attrs:{href:"https://docs.rs/log-derive/",target:"_blank",rel:"noopener noreferrer"}},[t._v("a macro that wraps a function in logging calls"),s("OutboundLink")],1),t._v(" and make a mistake in the implementation of the wrapped function, the compiler error will point directly to the mistake in your file, rather than saying the error occurred in code generated by the macro.")]),t._v(" "),s("h3",{attrs:{id:"syntax-tree-macros"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#syntax-tree-macros"}},[t._v("#")]),t._v(" Syntax tree macros")]),t._v(" "),s("p",[t._v("Some languages do take the step further and offer facilities for consuming and producing Abstract Syntax Tree (AST) types in macros written in the language. Examples of this include "),s("a",{attrs:{href:"https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial",target:"_blank",rel:"noopener noreferrer"}},[t._v("Template Haskell"),s("OutboundLink")],1),t._v(", "),s("a",{attrs:{href:"https://nim-lang.org/docs/tut3.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Nim macros"),s("OutboundLink")],1),t._v(", "),s("a",{attrs:{href:"http://ocamllabs.io/doc/ppx.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("OCaml PPX"),s("OutboundLink")],1),t._v(" and nearly all "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Lisp_(programming_language)",target:"_blank",rel:"noopener noreferrer"}},[t._v("Lisp"),s("OutboundLink")],1),t._v("s.")]),t._v(" "),s("p",[t._v("One problem with AST macros is that you donâ€™t want to require users to learn a bunch of functions for constructing AST types as well as the base languages. The Lisp family of languages address this by making the syntax and the AST structure very simple with a very direct correspondence, but constructing the structures can still be tedious. Thus, all the languages I mention have some form of â€œquoteâ€ primitive where you provide a fragment of code in the language and it returns the syntax tree. These quote primitives also have a way to splice syntax tree values in like string interpolation. Hereâ€™s an example in Template Haskell:")]),t._v(" "),s("div",{staticClass:"language-haskell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-haskell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- using AST construction functions")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("genFn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Name")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Q")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Exp")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("genFn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("f")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("newName")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"x"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("lamE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("varP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("appE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("varE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("varE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- using quotation with $() for splicing")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("genFn'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Name")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Q")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Exp")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("genFn'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("f")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("\\")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("varE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("p",[t._v("One disadvantage of doing procedural macros at the syntax tree level instead of token level is that syntax tree types often change with the addition of new language features, while token types can remain compatible. For example OCamlâ€™s PPX system needs "),s("a",{attrs:{href:"https://github.com/ocaml-ppx/ocaml-migrate-parsetree",target:"_blank",rel:"noopener noreferrer"}},[t._v("special infrastructure to migrate parse trees"),s("OutboundLink")],1),t._v(" to and from the language version used by a macro. Whereas Rust has libraries that add "),s("a",{attrs:{href:"https://github.com/dtolnay/syn",target:"_blank",rel:"noopener noreferrer"}},[t._v("parsing"),s("OutboundLink")],1),t._v(" and "),s("a",{attrs:{href:"https://github.com/dtolnay/quote",target:"_blank",rel:"noopener noreferrer"}},[t._v("quotation"),s("OutboundLink")],1),t._v(" utilities so you can write procedural macros in a style similar to syntax tree macros. Rust even has "),s("a",{attrs:{href:"https://github.com/dtolnay/reflect",target:"_blank",rel:"noopener noreferrer"}},[t._v("an experimental library that tries to replicate the interface provided by reflection"),s("OutboundLink")],1),t._v("!")]),t._v(" "),s("h3",{attrs:{id:"templates"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#templates"}},[t._v("#")]),t._v(" Templates")]),t._v(" "),s("p",[t._v("The next type of generics is just pushing the code generation a little further in the compiler. Templates as found in C++ and D are a way of implementing generics where you can specify â€œtemplate parametersâ€ on types and functions and when you instantiate a template with a specific type, that type is substituted into the function, and then the function is type checked to make sure that the combination is valid.")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("template <class T> T myMax(T a, T b) {\n  return (a>b?a:b);\n}\n\ntemplate <class T> struct Pair {\n  T values[2];\n};\n\nint main() {\n  myMax(5, 6);\n  Pair<int> p { {5,6} };\n  // This would give us a compile error inside myMax\n  // about Pair being an invalid operand to `>`:\n  // myMax(p, p);\n}\n")])])]),s("p",[t._v("One problem with the template system is that if you include a template function in your library and a user instantiates it with the wrong type they may get an inscrutable compile error inside your library. This is very similar to what can happen with libraries in dynamically typed languages when a user passes in the wrong type. "),s("a",{attrs:{href:"https://dlang.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("D"),s("OutboundLink")],1),t._v(" has an interesting solution to this which is similar to what popular libraries in dynamic languages do: just use helper functions to check the types are valid, the error messages will clearly point to the helpers if they fail! Hereâ€™s the same example in D, note the "),s("code",[t._v("if")]),t._v(" in the signature and the generally better syntax ("),s("code",[t._v("!")]),t._v(" is how you provide template parameters):")]),t._v(" "),s("div",{staticClass:"language-D extra-class"},[s("pre",{pre:!0,attrs:{class:"language-d"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// We're going to use the isNumeric function in std.traits")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("traits"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The `if` is optional (without it you'll get an error inside like C++)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The `if` is also included in docs and participates in overloading!")]),t._v("\nT "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myMax")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" T b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("isNumeric"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("b?a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Pair")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myMax")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  Pair"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This would give a compile error saying that `(Pair!int, Pair!int)`")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`:")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// myMax(p, p);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[s("a",{attrs:{href:"https://en.cppreference.com/w/cpp/language/constraints",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++20 has a feature called â€œconceptsâ€"),s("OutboundLink")],1),t._v(" that serves the same purpose except with a design more like defining interfaces and type constraints.")]),t._v(" "),s("h3",{attrs:{id:"compile-time-functions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compile-time-functions"}},[t._v("#")]),t._v(" Compile time functions")]),t._v(" "),s("p",[t._v("Dâ€™s templates have a number of extensions that allow you to use features like compile time function evaluation and "),s("code",[t._v("static if")]),t._v(" to basically make templates act like functions that take a compile time set of parameters and return a non-generic runtime function. This makes D templates into a fully featured metaprogramming system, and as far as I understand modern C++ templates have similar power but with less clean mechanisms.")]),t._v(" "),s("p",[t._v("Thereâ€™s some languages that take the â€œgenerics are just compile time functionsâ€ concept and run with it even further, like Zig:")]),t._v(" "),s("div",{staticClass:"language-zig extra-class"},[s("pre",{pre:!0,attrs:{class:"language-zig"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Stack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("comptime")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token builtin-types keyword"}},[t._v("type")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token builtin-types keyword"}},[t._v("type")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        items"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token builtin-types keyword"}},[t._v("usize")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Self "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("@This")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Zig does this using the same language at both compile time and runtime, with functions split up based on parameters marked "),s("code",[t._v("comptime")]),t._v(". Thereâ€™s another language that uses a separate but similar language at the meta level called "),s("a",{attrs:{href:"http://terralang.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Terra"),s("OutboundLink")],1),t._v(". Terra is a dialect of Lua that allows you to construct lower level C-like functions inline and then manipulate them at the meta level using Lua APIs as well as quoting and splicing primitives:")]),t._v(" "),s("div",{staticClass:"language-lua extra-class"},[s("pre",{pre:!0,attrs:{class:"language-lua"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MakeStack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("local")]),t._v(" struct "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Stack")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        items "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- &T is a pointer to T")]),t._v("\n        len "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" int"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    terra Stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("item "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ...")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Stack\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n")])])]),s("p",[t._v("Terraâ€™s crazy level of metaprogramming power allows it to do things "),s("a",{attrs:{href:"http://terralang.org/#compiling-a-language",target:"_blank",rel:"noopener noreferrer"}},[t._v("like implement optimizing compilers for domain specific languages as simple functions"),s("OutboundLink")],1),t._v(", or implement the interface and object systems of "),s("a",{attrs:{href:"https://github.com/zdevito/terra/blob/master/tests/lib/javalike.t",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java"),s("OutboundLink")],1),t._v(" and "),s("a",{attrs:{href:"https://github.com/zdevito/terra/blob/master/tests/lib/golike.t",target:"_blank",rel:"noopener noreferrer"}},[t._v("Go"),s("OutboundLink")],1),t._v(" in a library with a small amount of code. Then it can save out generated runtime-level code as dependency-free object files.")]),t._v(" "),s("h3",{attrs:{id:"rust-generics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-generics"}},[t._v("#")]),t._v(" Rust generics")]),t._v(" "),s("p",[t._v("The next type of monomorphized generics of course moves the code generation one step further into the compiler, after type checking. I mentioned that the type of inside-the-library errors you can get with C++ are like the errors you can get in a dynamically typed language, this is of course because thereâ€™s basically only one type of type in template parameters, like a dynamic language. So that means we can fix the problem by adding a type system to our meta level and having multiple types of types with static checking that they support the operations you use. This is how generics work in Rust, and at the language level also how they work in Swift and Haskell.")]),t._v(" "),s("p",[t._v("In Rust you need to declare â€œtrait boundsâ€ on your type parameters, where "),s("code",[t._v("trait")]),t._v("s are like interfaces in other languages and declare a set of functionality provided by the type. The Rust compiler will check that the body of your generic functions will work with any type conforming to your trait bounds, and also not allow you to use functionality of the type not declared by the trait bounds. This way users of generic functions in Rust can "),s("em",[t._v("never")]),t._v(" get compile errors inside a library function when they instantiate it. The compiler also only has to type check each generic function once.")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("my_max")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PartialOrd")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Pair")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("my_max")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pair")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pair")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Would give a compile error saying that")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// PartialOrd is not implemented for Pair<i32>:")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// my_max(p,p);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("At the language level this is very similar to the kind of type system you need to implement generics with interface support using the boxing approach to generics, which is why Rust can support both using the same system! Rust 2018 even added a uniform syntax where a "),s("code",[t._v("v: &impl SomeTrait")]),t._v(" parameter gets monomorphized but a "),s("code",[t._v("v: &dyn SomeTrait")]),t._v(" parameter uses boxing. This property also allows compilers like Swiftâ€™s and Haskellâ€™s GHC to monomorphize as an optimization even though they default to boxing.")]),t._v(" "),s("h3",{attrs:{id:"machine-code-monomorphization"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#machine-code-monomorphization"}},[t._v("#")]),t._v(" Machine code monomorphization")]),t._v(" "),s("p",[t._v("The logical next step in monomorphized generics models is pushing it further in the compiler, after the backend. Just like we can copy source code templates that are annotated with placeholders for the generic type, we can generate machine code with placeholders for the type-specific parts. Then we can stamp these templates out very quickly with a "),s("code",[t._v("memcpy")]),t._v(" and a few patches like how a linker works! The downside is that each monomorphized copy couldnâ€™t be specially optimized by the optimizer, but because of the lack of duplicate optimization, compilation can be way faster. We could even make the code stamper a tiny JIT that gets included in binaries and stamps out the monomorphized copies at runtime to avoid bloating the binaries.")]),t._v(" "),s("p",[t._v("Actually Iâ€™m not aware of any language that works this way, itâ€™s just an idea that came to me while writing as a natural extension of this taxonomy, which is exactly the kind of thing I hoped for from this exercise! I hope this post gives you a clearer picture of the generics systems in different languages and how they can be fit together into a coherent taxonomy, and prompts you to think about the directions in concept-space where we might find new cool programming languages.")]),t._v(" "),s("p",[t._v("å‚è€ƒèµ„æ–™")]),t._v(" "),s("p",[t._v("åŸæ–‡ï¼š"),s("a",{attrs:{href:"https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Models of Generics and Metaprogramming: Go, Rust, Swift, D and More - Tristan Hume (thume.ca)"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("è¯‘æ–‡ï¼š"),s("a",{attrs:{href:"https://blog.csdn.net/weixin_45583158/article/details/109664612",target:"_blank",rel:"noopener noreferrer"}},[t._v("æ³›å‹å’Œå…ƒç¼–ç¨‹çš„æ¨¡å‹ï¼šJava, Go, Rust, Swift, Dç­‰_é«˜å¯ç”¨æ¶æ„çš„åšå®¢-CSDNåšå®¢"),s("OutboundLink")],1)]),t._v(" "),s("Comment",{attrs:{lang:"zh-CN"}})],1)}),[],!1,null,null,null);a.default=n.exports}}]);