(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{431:function(e,t,i){e.exports=i.p+"assets/img/v2-ecfef5caf01b95cc40c6e37e69dd48f2_720w.7d6d60d7.jpg"},517:function(e,t,i){"use strict";i.r(t);var r=i(12),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#virtio详细介绍"}},[e._v("virtio详细介绍")])]),r("li",[r("a",{attrs:{href:"#基本要素"}},[e._v("基本要素")])]),r("li",[r("a",{attrs:{href:"#初始化"}},[e._v("初始化")])]),r("li",[r("a",{attrs:{href:"#承载"}},[e._v("承载")])]),r("li",[r("a",{attrs:{href:"#设备分类"}},[e._v("设备分类")])]),r("li",[r("a",{attrs:{href:"#举例分析"}},[e._v("举例分析")])]),r("li",[r("a",{attrs:{href:"#virtio1-1新功能"}},[e._v("virtio1.1新功能")])]),r("li",[r("a",{attrs:{href:"#实现情况"}},[e._v("实现情况")])]),r("li",[r("a",{attrs:{href:"#总结"}},[e._v("总结")])])])]),r("p"),e._v(" "),r("p",[e._v("最近在看一些虚拟化相关的东西，转载下一则专栏中 "),r("a",{attrs:{href:"https://www.zhihu.com/column/huiweics",target:"_blank",rel:"noopener noreferrer"}},[e._v("虚拟化笔记"),r("OutboundLink")],1),e._v(" 的文章，侵删")]),e._v(" "),r("p",[e._v("在知乎上看到的文章，然后发现曹钦翔老师也关注了作者= =")]),e._v(" "),r("h1",{attrs:{id:"virtio详细介绍和1-1新功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtio详细介绍和1-1新功能"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/361918197",target:"_blank",rel:"noopener noreferrer"}},[e._v("virtio详细介绍和1.1新功能"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("virtio是一种实践出来的技术，并且最终标准化，virtio是一种通用的虚拟化设备模拟标准，得到了大部分guest操作系统和hypervisor的支持，方便guest操作系统和hypervisor之间任意互相匹配。virtio出现之前hypervisor各有各的IO设备模拟方案，并在guest操作系统中大量合入驱动代码，导致一片混乱，后来xen中出来了部分virtio思想，在kvm中实现并且发扬光大，发表了论文《virtio: Towards a De-Facto Standard For Virtual I/O Devices》，论文促使virtio形成了正式标准。virtio标准最早是0.9.5版本(Virtio PCI Card Specification Version 0.9.5)，于2012年形成了draft，并没有正式发布，继续发展，2016年发布了1.0版本(Virtual I/O Device (VIRTIO) Version 1.0)，2019年发布了1.1版本(Virtual I/O Device (VIRTIO) Version 1.1)。")]),e._v(" "),r("h2",{attrs:{id:"virtio详细介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtio详细介绍"}},[e._v("#")]),e._v(" virtio详细介绍")]),e._v(" "),r("p",[e._v("virtio分为driver和device，driver部分运行于guest操作系统中，device部分运行于hypervisor中，driver和device是生产者和消费者模式动作，driver生产内存，device消费内存。不同virtio版本之间是互相兼容的，driver和device版本不同也可以互相运转。")]),e._v(" "),r("h2",{attrs:{id:"基本要素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本要素"}},[e._v("#")]),e._v(" 基本要素")]),e._v(" "),r("p",[r("img",{attrs:{src:i(431),alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("device status field")])]),e._v(" "),r("p",[e._v("driver发现了device，driver可以正常驱动device，driver或者device出错了，driver或者device要进行reset。")]),e._v(" "),r("ul",[r("li",[e._v("device feature bit")])]),e._v(" "),r("p",[e._v("driver和device协商feature以便于不同virtio版本之间兼容。")]),e._v(" "),r("ul",[r("li",[e._v("notification")])]),e._v(" "),r("p",[e._v("driver和device互通通知对方，driver生产好的内存要通知device去消费，device消费完了要通知driver回收内存。")]),e._v(" "),r("p",[e._v("driver通知deivce用doorbell机制，在kvm中是写寄存器，kvm进行拦截再通知vhost。")]),e._v(" "),r("p",[e._v("device通知driver用中断机制，在kvm中是中断注入。")]),e._v(" "),r("ul",[r("li",[e._v("config space")])]),e._v(" "),r("p",[e._v("典型的如virtio-net-device的MAC地址/MTU/最大支持队列数等。")]),e._v(" "),r("ul",[r("li",[e._v("virtqueue")])]),e._v(" "),r("p",[e._v("每个virtqueue分成这三部分，descriptor/available/used，descriptor/available/used就是三个大数组，descriptor数组内容存放真正东西，available和used数组内容存放descriptor数组的下标。driver生产内存，把生产的内存地址和长度写在descriptor，然后把descriptor数据下标写到available数组中，通知device，device消费内存，消费完再把descriptor的数据下标定到used数组中，通知driver进行内存回收。")]),e._v(" "),r("p",[e._v("chained descriptor，几个desciptor项连在一起，适用于scater-gather。")]),e._v(" "),r("p",[e._v("indirect descriptor，主descriptor中一项指向另一个descriptor数组。")]),e._v(" "),r("p",[e._v("一般设备的virtqueue基本可以分三类rx virtqueue/tx virtqueue/ctrl virtqueue，rx virtqueue和tx virtqueue用于进行IO，driver通过ctrl virtqueue控制device。")]),e._v(" "),r("div",{staticClass:"language-text extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */\nstruct vring_desc {\n    /* Address (guest-physical). */\n    __virtio64 addr;\n    /* Length. */\n    __virtio32 len;\n    /* The flags as indicated above. */\n    __virtio16 flags;\n    /* We chain unused descriptors via this, too */\n    __virtio16 next;\n};\n \nstruct vring_avail {\n    __virtio16 flags;\n    __virtio16 idx;\n    __virtio16 ring[];\n};\n \n/* uint32_t is used here for ids for padding reasons. */\nstruct vring_used_elem {\n    /* Index of start of used descriptor chain. */\n    __virtio32 id;\n    /* Total length of the descriptor chain which was used (written to) */\n    __virtio32 len;\n};\n \ntypedef struct vring_used_elem __attribute__((aligned(VRING_USED_ALIGN_SIZE)))\n    vring_used_elem_t;\n \nstruct vring_used {\n    __virtio16 flags;\n    __virtio16 idx;\n    vring_used_elem_t ring[];\n};\n')])])]),r("p",[e._v("used和avaible不一样是因为rx时，device给driver写数据，device写多少长度数据要给driver反回去。")]),e._v(" "),r("h2",{attrs:{id:"初始化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[e._v("#")]),e._v(" 初始化")]),e._v(" "),r("p",[e._v("device准备，driver发现device，状态更新和feature协商，driver分配virtqueue，把virtqueue地址告诉device。")]),e._v(" "),r("h2",{attrs:{id:"承载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#承载"}},[e._v("#")]),e._v(" 承载")]),e._v(" "),r("p",[e._v("首先virtio设备是IO设备，IO设备得以某种方式和CPU内存联结在一起，IO设备还得以某种方式和内存交互数据，IO设备还得提供一种机制让CPU控制IO设备。")]),e._v(" "),r("p",[e._v("virtio标准中有三种承载机制，分别是pci,mmio和channel i/o，pci是最通用的计算机bus，qemu和kvm能很好的模拟pci bus，mmio主要用于嵌入式设备，这些设备没有pci bus，channel i/o用于一些IBM机器，很少见。这里以最常见的pci来说，它的作用就是让driver正常发现device，让driver有方法控制device，如写pci配置空间，写pci bar空间。")]),e._v(" "),r("div",{staticClass:"language-text extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("typedef struct VirtIOPCIRegion {\n    MemoryRegion mr;\n    uint32_t offset;\n    uint32_t size;\n    uint32_t type;\n} VirtIOPCIRegion;\n \ntypedef struct VirtIOPCIQueue {\n  uint16_t num;\n  bool enabled;\n  uint32_t desc[2];\n  uint32_t avail[2];\n  uint32_t used[2];\n} VirtIOPCIQueue;\n \nstruct VirtIOPCIProxy {\n    PCIDevice pci_dev;\n    MemoryRegion bar;\n    union {\n        struct {\n            VirtIOPCIRegion common;\n            VirtIOPCIRegion isr;\n            VirtIOPCIRegion device;\n            VirtIOPCIRegion notify;\n            VirtIOPCIRegion notify_pio;\n        };\n        VirtIOPCIRegion regs[5];\n    };\n    MemoryRegion modern_bar;\n    MemoryRegion io_bar;\n    uint32_t legacy_io_bar_idx;\n    uint32_t msix_bar_idx;\n    uint32_t modern_io_bar_idx;\n    uint32_t modern_mem_bar_idx;\n    int config_cap;\n    uint32_t flags;\n    bool disable_modern;\n    bool ignore_backend_features;\n    OnOffAuto disable_legacy;\n    uint32_t class_code;\n    uint32_t nvectors;\n    uint32_t dfselect;\n    uint32_t gfselect;\n    uint32_t guest_features[2];\n    VirtIOPCIQueue vqs[VIRTIO_QUEUE_MAX];\n \n    VirtIOIRQFD *vector_irqfd;\n    int nvqs_with_notifiers;\n    VirtioBusState bus;\n};\n")])])]),r("p",[e._v("VirtIOPCIProxy存储virtio信息，kvm给guest注册了很多memory region，driver写这些memory region，kvm拦截，把写的值放在VirtIOPCIProxy中。")]),e._v(" "),r("div",{staticClass:"language-text extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('static void virtio_pci_modern_regions_init(VirtIOPCIProxy *proxy,\n                                           const char *vdev_name)\n{\n    static const MemoryRegionOps common_ops = {\n        .read = virtio_pci_common_read,\n        .write = virtio_pci_common_write,\n        .impl = {\n            .min_access_size = 1,\n            .max_access_size = 4,\n        },\n        .endianness = DEVICE_LITTLE_ENDIAN,\n    };\n    g_string_printf(name, "virtio-pci-common-%s", vdev_name);\n    memory_region_init_io(&amp;proxy->common.mr, OBJECT(proxy),\n                          &amp;common_ops,\n                          proxy,\n                          name->str,\n                          proxy->common.size);\n}\nstatic void virtio_pci_common_write(void *opaque, hwaddr addr,\n                                    uint64_t val, unsigned size)\n{\n    VirtIOPCIProxy *proxy = opaque;\n    VirtIODevice *vdev = virtio_bus_get_device(&amp;proxy->bus);\n \n    switch (addr) {\n    case VIRTIO_PCI_COMMON_DFSELECT:\n        proxy->dfselect = val;\n        break;\n    case VIRTIO_PCI_COMMON_GFSELECT:\n        proxy->gfselect = val;\n        break;\n    \n    default:\n        break;\n    }\n}\n')])])]),r("h2",{attrs:{id:"设备分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设备分类"}},[e._v("#")]),e._v(" 设备分类")]),e._v(" "),r("p",[e._v("virtio分为很多设备类型virtio-net/virtio-blk/virtio-scsi等等，virtqueue实现通用部分，每种设备再实现具体功能部分，可以扩展feature部分，在virtqueue传输的数据中定义自己功能相关标准等。")]),e._v(" "),r("h2",{attrs:{id:"举例分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#举例分析"}},[e._v("#")]),e._v(" 举例分析")]),e._v(" "),r("p",[e._v("以qemu中实现的virtio-net-pci举例来说")]),e._v(" "),r("p",[e._v("首先它是一个virtio-net类型设备，其次它承载在pci上，所以VirtIONetPCI就把两者结合起来了。")]),e._v(" "),r("div",{staticClass:"language-text extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("struct VirtIONetPCI {\n    VirtIOPCIProxy parent_obj;\n    VirtIONet vdev;\n};\n")])])]),r("p",[e._v("virtqueue实现了数据共享，它并不关心到底是网络还是存储数据，所以要在它的buf最前面加上设备类型自己的元数据头，virtio-net-pci用了virtio_net_hdr。")]),e._v(" "),r("div",{staticClass:"language-text extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/* This header comes first in the scatter-gather list.\n * For legacy virtio, if VIRTIO_F_ANY_LAYOUT is not negotiated, it must\n * be the first element of the scatter-gather list.  If you don't\n * specify GSO or CSUM features, you can simply ignore the header. */\nstruct virtio_net_hdr {\n    /* See VIRTIO_NET_HDR_F_* */\n    uint8_t flags;\n    /* See VIRTIO_NET_HDR_GSO_* */\n    uint8_t gso_type;\n    __virtio16 hdr_len;     /* Ethernet + IP + tcp/udp hdrs */\n    __virtio16 gso_size;        /* Bytes to append to hdr_len per frame */\n    __virtio16 csum_start;  /* Position to start checksumming from */\n    __virtio16 csum_offset; /* Offset after that to place checksum */\n};\n")])])]),r("p",[e._v("再看virtio-net-pci ctrl virtqueue传输的数据内容，基本就是打开网卡混杂模式/修改MAC/virtqueue个数/配置rss/配置offload等。")]),e._v(" "),r("div",{staticClass:"language-text extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/*\n * Control virtqueue data structures\n *\n * The control virtqueue expects a header in the first sg entry\n * and an ack/status response in the last entry.  Data for the\n * command goes in between.\n */\nstruct virtio_net_ctrl_hdr {\n    uint8_t class;\n    uint8_t cmd;\n} QEMU_PACKED;\n")])])]),r("h2",{attrs:{id:"virtio1-1新功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtio1-1新功能"}},[e._v("#")]),e._v(" virtio1.1新功能")]),e._v(" "),r("p",[e._v("virtio 1.0存在的问题第一是性能不高，第二是硬件不太好实现。")]),e._v(" "),r("p",[e._v("driver和device运行在不同的cpu，driver和device共享内存，存在不同cpu之间互相通知进行cache刷新的问题，virtio1.0 virtqueue分成三个数组，三个数组分布在不同的cacheline上需要多次cache刷新，所以virtio 1.1引入了packed ring，把virtio 1.0中的三个数组合并成一个，这样大大减少了cache刷新的次数。具体做法就是packed virtqueue把available和used当成descriptor中flag字段两个bit，driver本地存放一个driver_local_bit，把available_bit=driver_local_bit和used_bit=!driver_local_bit，device本地存放一个device_local_bit，消费完内存后used_bit=device_local_bit。")]),e._v(" "),r("p",[e._v("通知是有开销的，virtio1.1 batch和in-order减少driver和device互相通知对方的次数，batch就是driver一次多生产几块内存，再通知device，in-order就是device按driver生产内存的顺序消费内存，消费完后只通知driver最后一块内存可以回收了，因为严格按顺序消费的，driver由此可知前面的内存也已经消费完了。")]),e._v(" "),r("div",{staticClass:"language-text extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("struct vring_packed_desc {\n    /* Buffer Address. */\n    uint64_t addr;\n    /* Buffer Length. */\n    uint32_t len;\n    /* Buffer ID. */\n    uint16_t id;\n    /* The flags depending on descriptor type. */\n    uint16_t flags;\n};\n")])])]),r("p",[e._v("硬件实现也一样，driver写descriptor发现一次pci传输，写available数组又要发现一次pci传输，如果把descriptor和available数组合并只要一次pci传输即可。")]),e._v(" "),r("h2",{attrs:{id:"实现情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现情况"}},[e._v("#")]),e._v(" 实现情况")]),e._v(" "),r("p",[e._v("linux 4.18 virtio-net driver已经能支持virtio 1.1了，但vhost-net不支持virtio 1.1。")]),e._v(" "),r("p",[e._v("qemu master实现了virtio 1.1。")]),e._v(" "),r("p",[e._v("dpdk virtio pmd和vhost-user都支持virtio 1.1。")]),e._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("virtio标准还会继续发展，功能会越来越多，设备类型会越来越多，如virtio GPU和virtio vIOMMU，GPU最难虚拟化，目前用的是mdev，没有IOMMU，virtio设备可以修改任意guest内存，有vIOMMU更安全，vIOMMU也可以用vt-d实现，virtio device emulation可以在qemu/kernel/dpdk中实现，virtio技术百花齐放，创新不断，是做虚拟化必须研究的技术。总结virtio的目标就是统一IO设备，虚拟机看到的所有的外设都是virtio类型，只需要安装virtio类型的驱动即可，如果硬件也能实现virtio，那么裸金属也一样了，虚拟机和裸金属互相热迁移，一个镜像走天下。")]),e._v(" "),r("Comment",{attrs:{lang:"zh-CN"}})],1)}),[],!1,null,null,null);t.default=n.exports}}]);