(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{465:function(e,t,a){"use strict";a.r(t);var r=a(12),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"yet-another-json-lib"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yet-another-json-lib"}},[e._v("#")]),e._v(" Yet Another JSON Lib")]),e._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#命名空间、作用域"}},[e._v("命名空间、作用域")])]),a("li",[a("a",{attrs:{href:"#强枚举类型"}},[e._v("强枚举类型")])]),a("li",[a("a",{attrs:{href:"#使用了的智能指针"}},[e._v("使用了的智能指针")])]),a("li",[a("a",{attrs:{href:"#去掉了手写的数据结构"}},[e._v("去掉了手写的数据结构")])]),a("li",[a("a",{attrs:{href:"#未做oop实现-建议-参考-https-github-com-zsmj2017-minijson"}},[e._v("未做OOP实现 建议参考")])])])]),a("p"),e._v(" "),a("p",[e._v("一直找不到一个简单的Modern C++项目练手，在github上找了很久都太复杂了。最近在知乎上读到了一个写JSON库解析的"),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/json-tutorial",target:"_blank",rel:"noopener noreferrer"}},[e._v("系列教程"),a("OutboundLink")],1),e._v("（后续简写为教程），作者是写给C初学者的。")]),e._v(" "),a("p",[e._v("想了想我太菜了，果然还是这种事无巨细的教程适合我QAQ，于是就动手了："),a("a",{attrs:{href:"https://github.com/Forsworns/yJson",target:"_blank",rel:"noopener noreferrer"}},[e._v("项目地址"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("p",[e._v("既然主要目的是练习新标准，所以难免有拿着锤子看到哪都是钉子的感觉。可惜这个项目里没有多少用到模板的地方，好多deep♂dark♂magic都还没有试过。设计上和教程相同，也没有过多使用OOP。")]),e._v(" "),a("p",[e._v("那么在原教程的基础上的主要改动如下：")]),e._v(" "),a("h3",{attrs:{id:"命名空间、作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间、作用域"}},[e._v("#")]),e._v(" 命名空间、作用域")]),e._v(" "),a("p",[e._v("很自然的使用了命名空间防止冲突，干掉了原来的前缀。")]),e._v(" "),a("p",[a("code",[e._v("using")]),e._v("的新语义用来替代"),a("code",[e._v("typedef")]),e._v("也很舒服。")]),e._v(" "),a("p",[e._v("c++17可以在"),a("code",[e._v("if/switch")]),e._v("中定义并初始化变量，在"),a("code",[e._v("parseArray")]),e._v("和"),a("code",[e._v("parseObject")]),e._v("中。")]),e._v(" "),a("h3",{attrs:{id:"强枚举类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强枚举类型"}},[e._v("#")]),e._v(" 强枚举类型")]),e._v(" "),a("p",[e._v("主要就是把原来的枚举都改成了强枚举类型。教程中用到的")]),e._v(" "),a("p",[e._v("不过现在用起来可能会更冗杂……毕竟需要加类名。")]),e._v(" "),a("h3",{attrs:{id:"使用了的智能指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用了的智能指针"}},[e._v("#")]),e._v(" 使用了的智能指针")]),e._v(" "),a("p",[e._v("C++内存、锁、套接字等资源管理的思路是RAII（Resource Acquisition Is Initialization），资源在初始化时获取、在离开作用域后销毁。感谢智能指针，干掉了教程里的"),a("code",[e._v("free")]),e._v("，在教育意义上似乎是种退步😆。但是好处是不用担心内存泄漏问题了。")]),e._v(" "),a("p",[e._v("在"),a("code",[e._v("parseObject")]),e._v("函数中，没有直接创建指向"),a("code",[e._v("Entry el")]),e._v("的"),a("code",[e._v("val")]),e._v("的指针，而是选择和解析"),a("code",[e._v("el->key")]),e._v("一样，使用临时变量"),a("code",[e._v("elKey")]),e._v("和"),a("code",[e._v("elVal")]),e._v("传递。有两种常见的错误方式：如果是用"),a("code",[e._v("auto elVal = make_shared<Value>(el->val)")]),e._v("会将"),a("code",[e._v("el->val")]),e._v("复制一份，调用"),a("code",[e._v("parseValue(s, elVal)")]),e._v("不会修改"),a("code",[e._v("el->Val")]),e._v("；如果是用"),a("code",[e._v("shared_ptr<Value> elVal(&el->val)")]),e._v("，则会导致"),a("code",[e._v("shared_ptr")]),e._v("在执行析构的时候，重复析构"),a("code",[e._v("el->val")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"去掉了手写的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#去掉了手写的数据结构"}},[e._v("#")]),e._v(" 去掉了手写的数据结构")]),e._v(" "),a("p",[e._v("干掉了手写的复杂数据结构，改用了标准库，比起教程似乎也是一种退步😆。比较值得一提的是，在解析对象的时候，本来设想的是使用"),a("code",[e._v("unordered_map")]),e._v("。但是由于数据结构间互相引用，需要前向声明一个不完整的类。这个时候就出现了一个坑，C++标准库中的容器不支持使用不完整类型，似乎boost做了支持（未考证），而标准库则直到C++17才允许部分容器使用不完整类型。也就是说，目前只有"),a("code",[e._v("vector")]),e._v(","),a("code",[e._v("list")]),e._v("和"),a("code",[e._v("forward_list")]),e._v("支持使用不完整类型，如下")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class A; // forward declaration\nusing myVec = vector<A>; // right\nvector<A> a; // right\n// using myMap = map<int,A>; wrong\n// map<int,A> b; // wrong\nclass A{};\n")])])]),a("h3",{attrs:{id:"未做oop实现-建议参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#未做oop实现-建议参考"}},[e._v("#")]),e._v(" 未做OOP实现 建议"),a("a",{attrs:{href:"https://github.com/zsmj2017/MiniJson",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/zh/blogs/"}},[e._v("返回")])],1),e._v(" "),a("Comment",{attrs:{lang:"zh-CN"}})],1)}),[],!1,null,null,null);t.default=v.exports}}]);