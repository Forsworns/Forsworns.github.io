(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{489:function(t,s,a){"use strict";a.r(s);var n=a(12),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#rust中宏的分类"}},[t._v("Rust中宏的分类")])]),a("li",[a("a",{attrs:{href:"#声明式宏"}},[t._v("声明式宏")])]),a("li",[a("a",{attrs:{href:"#过程式宏"}},[t._v("过程式宏")]),a("ul",[a("li",[a("a",{attrs:{href:"#custom-derive-宏"}},[t._v("Custom Derive 宏")])]),a("li",[a("a",{attrs:{href:"#attribute-like-宏"}},[t._v("Attribute-Like 宏")])]),a("li",[a("a",{attrs:{href:"#function-like-宏"}},[t._v("Function-Like 宏")])])])]),a("li",[a("a",{attrs:{href:"#好用的库"}},[t._v("好用的库")])]),a("li",[a("a",{attrs:{href:"#收录有趣的宏样例"}},[t._v("收录有趣的宏样例")]),a("ul",[a("li",[a("a",{attrs:{href:"#你这写的啥啊"}},[t._v("你这写的啥啊")])]),a("li",[a("a",{attrs:{href:"#还得学习一个"}},[t._v("还得学习一个")])])])]),a("li",[a("a",{attrs:{href:"#references"}},[t._v("References")])])])]),a("p"),t._v(" "),a("h1",{attrs:{id:"rust宏学习笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rust宏学习笔记"}},[t._v("#")]),t._v(" Rust宏学习笔记")]),t._v(" "),a("p",[t._v("前面的部分基本是 Rust 语言手册翻译。")]),t._v(" "),a("p",[t._v("Rust 中的宏相较C++更为强大。C++ 中的宏在预处理阶段可以展开为文本，Rust 的宏则是对语法的扩展，是在构建语法树时，才展开的宏。")]),t._v(" "),a("h2",{attrs:{id:"rust中宏的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rust中宏的分类"}},[t._v("#")]),t._v(" Rust中宏的分类")]),t._v(" "),a("p",[t._v("Rust 中宏可以分为很多类，包括通过 macro_rules 定义的"),a("strong",[t._v("声明式宏")]),t._v("和三种"),a("strong",[t._v("过程式宏")])]),t._v(" "),a("ul",[a("li",[t._v("custom derive 可推导宏，借助 "),a("code",[t._v("#[derive]")]),t._v(" 属性标签，它可以用在 struct 和 enum 上")]),t._v(" "),a("li",[t._v("attribute-like 本身就是一个标签，可以作用于任何地方")]),t._v(" "),a("li",[t._v("function-like 看上去像函数，但是作用在 token 上，即把token作为函数参数")])]),t._v(" "),a("p",[t._v("所以为什么需要宏？")]),t._v(" "),a("p",[t._v("为了偷懒、为了让代码更简洁。使用宏可以快速生成大量代码，避免重复劳动。Rust 宏扩展了语法，你是不会想要每次都老老实实地写繁复的代码的，所以学一点魔法！")]),t._v(" "),a("p",[t._v("为什么不用函数或者模板？")]),t._v(" "),a("ul",[a("li",[t._v("Rust 的函数必须限定好参数类型和参数个数，而且他并没有提供变长模板参数，所以嘛，哈哈。事实上有不少库为了应对未知个数参数的情况，手写了不同个数参数的函数，而且很蛋疼的是 Rust 也不允许同名函数的重载 😃 当然我还是最喜欢Rust了。")]),t._v(" "),a("li",[t._v("宏在编译期展开，所以可以用来给 struct 添加 trait，这必须在运行前完成，而函数需要等到运行时才会执行。")])]),t._v(" "),a("p",[t._v("但是坏处（如果算的话）就是宏更难书写、理解和维护；同时函数可以定义、引入在文件里的任何地方，而在使用宏之前必须确保他被定义、引入到上方的代码中了。")]),t._v(" "),a("p",[t._v("下面开始记录宏的写法！")]),t._v(" "),a("h2",{attrs:{id:"声明式宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明式宏"}},[t._v("#")]),t._v(" 声明式宏")]),t._v(" "),a("p",[t._v("在Rust中，应用最广泛的一种宏就是声明式宏，类似于模式匹配的写法，将传入的 Rust 代码与预先指定的模式进行比较，在不同模式下生成不同的代码。")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("macro_rules!")]),t._v("来定义一个声明式宏。")]),t._v(" "),a("p",[t._v("最基础的例子是很常见的"),a("code",[t._v("vec!")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("u32")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("vec!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("简化版的定义是（实际的版本有其他分支，而且该分支下要预先分配内存防止在push时候再动态分划）")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[macro_export]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("macro_rules!")]),t._v(" vec "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token fragment-specifier punctuation"}},[t._v("expr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" temp_vec "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n                temp_vec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n            temp_vec\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("#[macro_export]")]),t._v("标签是用来声明：只要 use 了这个crate，就可以使用该宏。同时包含被 export 出的宏的模块，在声明时必须放在前面，否则靠前的模块里找不到这些宏。")]),t._v(" "),a("p",[t._v("按照官方文档的说法，"),a("code",[t._v("macro_rules!")]),t._v("目前有一些设计上的问题，日后将推出新的机制来取代他。但是他依然是一个很有效的语法扩展方法。")]),t._v(" "),a("p",[t._v("这里一个注意点是：如果想要创建临时变量，那么必须要像上面这个例子这样，放在某个块级作用域内，以便自动清理掉，否则会认为是不安全的行为。")]),t._v(" "),a("p",[t._v(":::声明宏中支持的语法树元变量类型")]),t._v(" "),a("p",[t._v("出自 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/macros-by-example.html#metavariables",target:"_blank",rel:"noopener noreferrer"}},[t._v("Macros By Example - The Rust Reference"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("回顾编译原理 😃")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("item")]),t._v(": 随便一个什么 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/items.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("东西"),a("OutboundLink")],1),t._v("，准确定义参考上述手册中")]),t._v(" "),a("li",[a("code",[t._v("block")]),t._v(": 一个 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/expressions/block-expr.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("块表达式"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("code",[t._v("stmt")]),t._v(": 一个 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/statements.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("语句"),a("OutboundLink")],1),t._v("，但是不包含结尾的分号，除了必须有分号的 item statements")]),t._v(" "),a("li",[a("code",[t._v("pat_param")]),t._v(": 一个 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/patterns.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("匹配模式"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("code",[t._v("pat")]),t._v(": 等价于 "),a("code",[t._v("pat_param")])]),t._v(" "),a("li",[a("code",[t._v("expr")]),t._v(": 一个 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/expressions.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("表达式"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("code",[t._v("ty")]),t._v(": 一种 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/types.html#type-expressions",target:"_blank",rel:"noopener noreferrer"}},[t._v("类型"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("code",[t._v("ident")]),t._v(": 一个 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/identifiers.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("标识符或关键字"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("code",[t._v("path")]),t._v(": 一条 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/paths.html#paths-in-types",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypePath"),a("OutboundLink")],1),t._v(" 形式的路径")]),t._v(" "),a("li",[a("code",[t._v("tt")]),t._v(": "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/macros.html#macro-invocation",target:"_blank",rel:"noopener noreferrer"}},[t._v("Token 树"),a("OutboundLink")],1),t._v(" （一个独立的 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/tokens.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("token"),a("OutboundLink")],1),t._v(" 或一系列在匹配完整的定界符 "),a("code",[t._v("()")]),t._v("、"),a("code",[t._v("[]")]),t._v(" 或 "),a("code",[t._v("{}")]),t._v(" 中的 token）")]),t._v(" "),a("li",[a("code",[t._v("meta")]),t._v(":  "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/attributes.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("标签"),a("OutboundLink")],1),t._v(" 中的内容")]),t._v(" "),a("li",[a("code",[t._v("lifetime")]),t._v(":  一个 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/tokens.html#lifetimes-and-loop-labels",target:"_blank",rel:"noopener noreferrer"}},[t._v("生命周期标识"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("code",[t._v("vis")]),t._v(": 可能不存在的 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/visibility-and-privacy.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("可见性标记"),a("OutboundLink")],1),t._v("（并不是所有函数、类型都会使用 "),a("code",[t._v("pub")]),t._v(" 进行标记，所以可能是不存在的）")]),t._v(" "),a("li",[a("code",[t._v("literal")]),t._v(": 匹配 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/expressions/literal-expr.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("文本表达式"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v(":::")]),t._v(" "),a("h2",{attrs:{id:"过程式宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过程式宏"}},[t._v("#")]),t._v(" 过程式宏")]),t._v(" "),a("p",[t._v("第二类是过程式的宏，它更像函数，他接受一些代码作为参数输入，然后对他们进行加工，生成新的代码，他不是在做声明式宏那样的模式匹配。三种过程式宏都是这种思路。")]),t._v(" "),a("p",[t._v("不能在原始的crate中直接写过程式宏，需要把过程式宏放到一个单独的crate中（以后可能会消除这种约定）。定义过程式宏的方法如下：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" proc_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[some_attribute]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("some_name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("需要引入"),a("code",[t._v("proc_macro")]),t._v(" 这个 crate，然后标签是用来声明它是哪种过程式宏的，接着就是一个函数定义，函数接受 "),a("code",[t._v("TokenStream")]),t._v("，返回 "),a("code",[t._v("TokenStream")]),t._v("。"),a("code",[t._v("TokenStream")]),t._v(" 类型就定义在 "),a("code",[t._v("proc_macro")]),t._v(" 包中，表示 token 序列。除了标准库中的这个包，还可以使用"),a("code",[t._v("proc_macro2")]),t._v(" 包，使用 "),a("code",[t._v("proc_macro2::TokenStream::from()")]),t._v(" 和 "),a("code",[t._v("proc_macro::TokenStream::from()")]),t._v(" 可以很便捷地在两个包的类型间进行转换。使用 "),a("code",[t._v("proc_macro2")]),t._v(" 的好处是可以在过程宏外部使用 "),a("code",[t._v("proc_macro2")]),t._v(" 的类型，相反 "),a("code",[t._v("proc_macro")]),t._v(" 中的类型只可以在过程宏的上下文中使用。且 "),a("code",[t._v("proc_macro2")]),t._v(" 写出的宏更容易编写测试代码。")]),t._v(" "),a("p",[t._v("下面详细说明如何定义三类过程宏。")]),t._v(" "),a("h3",{attrs:{id:"custom-derive-宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#custom-derive-宏"}},[t._v("#")]),t._v(" Custom Derive 宏")]),t._v(" "),a("p",[t._v("在本节中，我们的目的是实现下面的代码，使用编译器为我们生成名为 "),a("code",[t._v("HelloMacro")]),t._v(" 的 "),a("code",[t._v("Trait")])]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("hello_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("hello_macro_derive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[derive(HelloMacro)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Pancakes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pancakes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("该 "),a("code",[t._v("Trait")]),t._v(" 的定义如下，目的是打印实现该宏的类型名")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("trait")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("由于过程宏不能在原 crate 中实现，我们需要如下在 "),a("code",[t._v("hello_crate")]),t._v(" 的目录下新建一个 "),a("code",[t._v("hello_macro_derive")]),t._v(" crate")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("cargo new hello_macro_derive --lib\n")])])]),a("p",[t._v("在新的 crate 内，我们需要修改 "),a("code",[t._v("Cargo.toml")]),t._v(" 配置文件，")]),t._v(" "),a("div",{staticClass:"language-toml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-toml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token table class-name"}},[t._v("lib")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("proc-macro")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token table class-name"}},[t._v("dependencies")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("syn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1.0"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("quote")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1.0"')]),t._v("\n")])])]),a("p",[t._v("在 "),a("code",[t._v("src/lib.rs")]),t._v(" 中可以着手实现该宏，其中 "),a("code",[t._v("syn")]),t._v(" 是用来解析 rust 代码的，而quote则可以用已有的变量生成代码的 "),a("code",[t._v("TokenStream")]),t._v("，可以认为 "),a("code",[t._v("quote!")]),t._v(" 宏内的就是我们想要生成的代码")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("crate")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token module-declaration namespace"}},[t._v("proc_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("proc_macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("quote"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),t._v("quote"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" syn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[proc_macro_derive(HelloMacro)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro_derive")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Construct a representation of Rust code as a syntax tree")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// that we can manipulate")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" ast "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("syn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unwrap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Build the trait implementation")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("impl_hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("impl_hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("syn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DeriveInput")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("ast"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ident"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" gen "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("quote!")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloMacro")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" #name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello_macro")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello, Macro! My name is {}!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("stringify!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("#name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    gen"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("into")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("另外，"),a("strong",[t._v("Custom Derive 宏可以携带Attributes，称为 Derive macro helper attributes")]),t._v("，具体编写方法可以参考 "),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes",target:"_blank",rel:"noopener noreferrer"}},[t._v("Reference"),a("OutboundLink")],1),t._v("（Rust 中共有"),a("a",{attrs:{href:"https://doc.rust-lang.org/reference/attributes.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("四类 Attributes"),a("OutboundLink")],1),t._v("）。关于 Derive macro helper attributes 这里有一个坑就是在使用 "),a("code",[t._v("cfg_attr")]),t._v(" 时，需要把 Attributes 放在宏之前。举个栗子：")]),t._v(" "),a("p",[t._v("使用 kube-rs 可以很方便地定义 CRD（Custom Resource Definition）：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[derive(CustomResource, Clone, Debug, Deserialize, Serialize, JsonSchema)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[kube(group = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"clux.dev"')]),t._v(", version = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"v1"')]),t._v(", kind = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Foo"')]),t._v(", namespaced)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("FooSpec")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    info"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("我第一反应是 #[kube] 在这里是下面提到的 Attribute-Like 宏，但是 kubers 文档才发现是 "),a("code",[t._v("CustomResource")]),t._v(" Custom Derive 宏的 Attribute。这里我们想用 "),a("code",[t._v("cfg_attr")]),t._v(" 来控制是否去做 derive，一开始就想当然地这么写了：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[cfg_attr(feature="),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"use_kube_rs"')]),t._v(",\n    derive(CustomResource, Clone, Debug, Deserialize, Serialize, JsonSchema),\n    kube(group = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"clux.dev"')]),t._v(", version = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"v1"')]),t._v(", kind = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Foo"')]),t._v(", namespaced)\n)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("FooSpec")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    info"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("然而这是错误的打开方式，需要写成：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[cfg_attr(feature="),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"use_kube_rs"')]),t._v(",\n    kube(group = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"clux.dev"')]),t._v(", version = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"v1"')]),t._v(", kind = "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Foo"')]),t._v(", namespaced),\n    derive(CustomResource, Clone, Debug, Deserialize, Serialize, JsonSchema)\n)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("FooSpec")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    info"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Attributes 需要写在宏的 derive 前面。")]),t._v(" "),a("h3",{attrs:{id:"attribute-like-宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attribute-like-宏"}},[t._v("#")]),t._v(" Attribute-Like 宏")]),t._v(" "),a("p",[t._v("attribute-like 宏和 custom derive 宏很相似，只是标签可以自定义，更加灵活，甚至可以使用在函数上。他的使用方法如下，比如假设有一个宏为 "),a("code",[t._v("route")]),t._v(" 的宏")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[route(GET, "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),t._v(")]")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("index")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("按下面的语法定义 "),a("code",[t._v("route")]),t._v(" 宏")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[proc_maco_attribute]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("route")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("attr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("其中 "),a("code",[t._v("attr")]),t._v(" 参数是上面的 "),a("code",[t._v("Get")]),t._v("，"),a("code",[t._v('"/"')]),t._v(" ；"),a("code",[t._v("item")]),t._v(" 参数是 "),a("code",[t._v("fn index(){}")]),t._v(" 。")]),t._v(" "),a("h3",{attrs:{id:"function-like-宏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-like-宏"}},[t._v("#")]),t._v(" Function-Like 宏")]),t._v(" "),a("p",[t._v("这种宏看上去和 "),a("code",[t._v("macro_rules!")]),t._v(" 比较类似，但是在声明式宏只能用 "),a("code",[t._v("match")]),t._v(" 去做模式匹配，但是在这里可以有更复杂的解析方式，所以可以写出来")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" sql "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("sql!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FROM")]),t._v(" posts "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("WHERE")]),t._v(" id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("上面这个 "),a("code",[t._v("sql")]),t._v(" 宏的定义方法如下")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[proc_macro]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("sql")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"好用的库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#好用的库"}},[t._v("#")]),t._v(" 好用的库")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://doc.rust-lang.org/proc_macro/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("proc_macro"),a("OutboundLink")],1),t._v("：默认 token 流库，只能在过程宏中使用，编译器要用它，将它作为过程宏的返回值，大多数情况我们不需要，只需要在宏返回结果的时候把 "),a("code",[t._v("proc_macro2::TokenSteam")]),t._v(" 的流 "),a("code",[t._v("into()")]),t._v(" 到 "),a("code",[t._v("proc_macro::TokenSteam")]),t._v(" 就行了。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://crates.io/crates/proc_macro2",target:"_blank",rel:"noopener noreferrer"}},[t._v("proc_macro2"),a("OutboundLink")],1),t._v("：我们真正在使用的过程宏库，可以在过程宏外使用。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://crates.io/crates/syn",target:"_blank",rel:"noopener noreferrer"}},[t._v("syn"),a("OutboundLink")],1),t._v("：过程宏左护法，可以将 "),a("code",[t._v("TokenStream")]),t._v(" 解析成语法树，注意两个 "),a("code",[t._v("proc_macro")]),t._v(" 和 "),a("code",[t._v("proc_macro")]),t._v(" 都支持，需要看文档搞清楚库函数到底是在解析哪个库中的 "),a("code",[t._v("TokenStream")]),t._v("。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://crates.io/crates/quote",target:"_blank",rel:"noopener noreferrer"}},[t._v("quote"),a("OutboundLink")],1),t._v("：过程宏右护法，将语法树解析成 "),a("code",[t._v("TokenStream")]),t._v("。只要一个 "),a("code",[t._v("quote!{}")]),t._v(" 就够了！"),a("code",[t._v("quote!{}")]),t._v(" 宏内都是字面量，即纯纯的代码，要替换进去的变量是用的 "),a("code",[t._v("#")]),t._v(" 符号标注，为了和声明宏中使用的 "),a("code",[t._v("$")]),t._v(" 相区分（也就意味着用 "),a("code",[t._v("quote")]),t._v(" 写过程宏的时候，可以和声明宏结合 🤤 ）。模式匹配时用到的表示重复的符号和声明宏中一样，是使用 "),a("code",[t._v("*")]),t._v("。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://crates.io/crates/darling",target:"_blank",rel:"noopener noreferrer"}},[t._v("darling"),a("OutboundLink")],1),t._v(" 好用到跺 jio jio 的标签宏解析库，让人直呼 Darling！")]),t._v(" "),a("h2",{attrs:{id:"收录有趣的宏样例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#收录有趣的宏样例"}},[t._v("#")]),t._v(" 收录有趣的宏样例")]),t._v(" "),a("p",[t._v("本章收录到的宏尽可能短小、独立、有趣。")]),t._v(" "),a("h3",{attrs:{id:"你这写的啥啊"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你这写的啥啊"}},[t._v("#")]),t._v(" 你这写的啥啊")]),t._v(" "),a("p",[t._v("记录一下自己写的一些有趣的宏，以防下次碰到这种情况忘记咋写。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("这里的实际需求是处理标签宏参数，用了 "),a("a",{attrs:{href:"https://crates.io/crates/darling",target:"_blank",rel:"noopener noreferrer"}},[t._v("darling"),a("OutboundLink")],1),t._v(" 库做解析，然后处理一些 "),a("code",[t._v("Option")]),t._v(" 类型的可选参数，如果标签宏参数中没有它（即 "),a("code",[t._v("darling")]),t._v(" 解析出 "),a("code",[t._v("None")]),t._v("），就不理会它，在后续构造中使用默认值。感觉有意思的地方在于过程宏和声明宏的混合使用，在写出来之前我没想到这么写真能跑 = =")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("macro_rules!")]),t._v(" expand_attribute "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("$"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$attr")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token fragment-specifier punctuation"}},[t._v("expr")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" token "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            $"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Some")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$attr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                token"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("extend")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("quote!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$attr")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" #val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n            token\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用时是这么用的")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("darling"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FromMeta")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[derive(Debug, FromMeta)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Attrs")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[darling(default)]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" param1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Option")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[darling(default)]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" param2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Option")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[darling(default)]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" param3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Option")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[derive(Debug, Default)]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Struct")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" param1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" param2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" neccessary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// cannot be empty or any default value")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[proc_macro_attribute]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("an_attribute")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("attr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Attrs")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        param1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n        param2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Attrs::param3 is not useful in Struct")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Attrs")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("from_list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("attr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ok")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Err")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TokenStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("from")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("write_errors")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" optional_params "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("expand_attribute!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("param1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" param2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" build_a_struct "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("quote!")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            neccessary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0817"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n            #optional_params\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Default")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("default")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TL;DR")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("看得出来还是比较繁琐的，")])]),t._v(" "),a("li",[a("p",[t._v("这里的实际需求是用标签宏修改原函数返回值为 Result，是在 "),a("a",{attrs:{href:"https://github.com/sentinel-group/sentinel-rust",target:"_blank",rel:"noopener noreferrer"}},[t._v("sentinel-group/sentinel-rust"),a("OutboundLink")],1),t._v(" 的实现中，用来快速给一个函数或方法创建 sentinel 的。当时的想法是用 Result 来表达某个流是否被阻碍，同时可以传递 Sentinel 的告警给用户，实现出来的很垃圾，可以说是只支持使用一个规则。没有试过多个这样的标签宏嵌套，但是估计是回调地狱重现世间 😅 （或许可以用 "),a("code",[t._v("std::Result::flatten()")]),t._v(" 来避免，但是它目前还是 nightly 的 API）。")]),t._v(" "),a("p",[t._v("这里的实现也有点蠢，是用的 quote 和 syn 自动解析的修改后的函数签名，尝试过手动构造，但是太恶心了构造不来。")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("crate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("process_func")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" func"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ItemFn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ItemFn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" output "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" func"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sig"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("output"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Currently, use quote/syn to automatically generate it,")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// don't know if there is a better way.")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Seems hard to parse new ReturnType only or construct ReturnType by hand.")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" dummy_func "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" output "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReturnType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("quote!")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("dummy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Result")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReturnType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Type")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" return_type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("quote!")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("dummy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Result")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("#return_type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" dummy_func"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ItemFn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("syn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dummy_func"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unwrap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// replace the old ReturnType to the dummy function ReturnType")]),t._v("\n    func"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sig"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("output "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" dummy_func"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sig"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("output"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    func\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"还得学习一个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#还得学习一个"}},[t._v("#")]),t._v(" 还得学习一个")]),t._v(" "),a("p",[t._v("本章节抄录一些别人写的黑魔法宏。")]),t._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[t._v("#")]),t._v(" References")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://doc.rust-lang.org/book/ch19-06-macros.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Macros - The Rust Programming Language (rust-lang.org)"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://doc.rust-lang.org/reference/macros.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Macros - The Rust Reference (rust-lang.org)"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://danielkeep.github.io/tlborm/book/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("The Little Book of Rust Macros (danielkeep.github.io)"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://dengjianping.github.io/2019/02/28/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%AE%8F(proc-macro).html",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何编写一个过程宏(proc-macro)"),a("OutboundLink")],1)]),t._v(" "),a("Comment",{attrs:{lang:"zh-CN"}})],1)}),[],!1,null,null,null);s.default=e.exports}}]);