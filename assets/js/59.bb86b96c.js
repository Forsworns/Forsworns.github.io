(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{478:function(t,s,a){"use strict";a.r(s);var n=a(12),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#string-vs-str"}},[t._v("String vs str")]),a("ul",[a("li",[a("a",{attrs:{href:"#相互转化"}},[t._v("相互转化")])]),a("li",[a("a",{attrs:{href:"#内存的分配"}},[t._v("内存的分配")])]),a("li",[a("a",{attrs:{href:"#应该使用哪一个"}},[t._v("应该使用哪一个？")])])])]),a("li",[a("a",{attrs:{href:"#life-time"}},[t._v("Life Time")]),a("ul",[a("li",[a("a",{attrs:{href:"#引用传参"}},[t._v("引用传参")])]),a("li",[a("a",{attrs:{href:"#返回引用"}},[t._v("返回引用")])]),a("li",[a("a",{attrs:{href:"#结构体"}},[t._v("结构体")])]),a("li",[a("a",{attrs:{href:"#多个生命周期参数"}},[t._v("多个生命周期参数")])])])]),a("li",[a("a",{attrs:{href:"#trait"}},[t._v("Trait")])]),a("li",[a("a",{attrs:{href:"#与-c-结合"}},[t._v("与 C++ 结合")])]),a("li",[a("a",{attrs:{href:"#杂项"}},[t._v("杂项")])]),a("li",[a("a",{attrs:{href:"#安全性"}},[t._v("安全性")]),a("ul",[a("li",[a("a",{attrs:{href:"#c-的情况"}},[t._v("C++的情况")])]),a("li",[a("a",{attrs:{href:"#rust是怎么做的"}},[t._v("Rust是怎么做的")])])])]),a("li",[a("a",{attrs:{href:"#references"}},[t._v("References")])])])]),a("p"),t._v(" "),a("h1",{attrs:{id:"rust-基础备忘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rust-基础备忘"}},[t._v("#")]),t._v(" Rust 基础备忘")]),t._v(" "),a("p",[t._v("转载和记录一些印象不深的碎片知识")]),t._v(" "),a("h2",{attrs:{id:"string-vs-str"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-vs-str"}},[t._v("#")]),t._v(" String vs str")]),t._v(" "),a("p",[t._v("当我们需要引用一个被拥有的UTF-8文本的区间(range)，或者当我们使用字符串字面量(string literals)时，我们就需要使用字符串切片(也就是 "),a("code",[t._v("str")]),t._v(")。"),a("code",[t._v("&str")]),t._v(" 不负责任地说，可以理解成 C++ 中的 "),a("code",[t._v("char *")]),t._v(" 和 "),a("code",[t._v("string_view")]),t._v("。"),a("code",[t._v("string_view")]),t._v("是 C++17 中为解决字符串频繁拷贝问题而提出的 ，在一些只需要做查找、遍历、打印的函数中，参数的常量引用传递并不能完全解决拷贝问题，如果传参时候传的是常量引用传递，内部一旦使用赋值等运算仍然会发生拷贝，会在堆上重新分配空间浪费时间，所以它和"),a("code",[t._v("&str")]),t._v("都相当于是字符指针的包装类型，不拥有数据，只是划一个区间。")]),t._v(" "),a("p",[a("code",[t._v("String")]),t._v(" 则可以认为和 C++ 中相同，是一个会自动分配空间的容器（而 Java 的 String 是常量）。")]),t._v(" "),a("h3",{attrs:{id:"相互转化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相互转化"}},[t._v("#")]),t._v(" 相互转化")]),t._v(" "),a("p",[t._v("像"),a("code",[t._v("println!")]),t._v("，"),a("code",[t._v("format!")]),t._v(" 这些宏都是要传 "),a("code",[t._v("&str")]),t._v(" 的。")]),t._v(" "),a("p",[a("code",[t._v("String")]),t._v(" 转 "),a("code",[t._v("&str")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("String")]),t._v(" 类型在引用时， "),a("code",[t._v("&String")]),t._v(" 可以自动转化为 "),a("code",[t._v("&str")]),t._v("，编译器会帮忙干活，该特性叫 "),a("code",[t._v("deref coercing")])]),t._v(" "),a("li",[t._v("使用"),a("code",[t._v("&some_string[..]")]),t._v(" 这样完整的写法，利用了String重载的Index操作")]),t._v(" "),a("li",[a("code",[t._v("as_str()")]),t._v("，"),a("code",[t._v("as_ref()")]),t._v("，"),a("code",[t._v("as_borrow()")])])]),t._v(" "),a("p",[a("code",[t._v("&str")]),t._v(" 转 "),a("code",[t._v("String")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("into()")]),t._v(" （这本质上是因为 "),a("code",[t._v("String")]),t._v(" 实现了 "),a("code",[t._v("From<&'_ str>")]),t._v(" 这个 trait ，调用了"),a("code",[t._v("to_owned()")])]),t._v(" "),a("li",[t._v("to_owned()，因为原来没有所有权么，所以要 "),a("code",[t._v("to_owned")]),t._v(" 成 "),a("code",[t._v("String")]),t._v(" 拿到所有权")]),t._v(" "),a("li",[a("code",[t._v("to_string()")]),t._v(" 调用的是 "),a("code",[t._v("String::from()")])]),t._v(" "),a("li",[a("code",[t._v("String::from()")])])]),t._v(" "),a("h3",{attrs:{id:"内存的分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存的分配"}},[t._v("#")]),t._v(" 内存的分配")]),t._v(" "),a("p",[t._v("讨论内存分配的例子：")]),t._v(" "),a("p",[a("code",[t._v('let my_name = "Pascal".to_string();')])]),t._v(" "),a("p",[t._v("那么")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("buffer\n                   /   capacity\n                 /   /  length\n               /   /   /\n            +–––+–––+–––+\nstack frame │ • │ 8 │ 6 │ &lt;- my_name: String\n            +–│–+–––+–––+\n              │\n            [–│–––––––– capacity –––––––––––]\n              │\n            +–V–+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+\n\n            [––––––– length ––––––––]\n")])])]),a("p",[t._v("Rust会在栈上存储"),a("code",[t._v("String")]),t._v("对象。这个对象里包含以下三个信息: 一个"),a("strong",[t._v("指针")]),t._v("指向一块分配在堆上的缓冲区，这也是数据真正存储的地方，数据的"),a("strong",[t._v("容量")]),t._v("和"),a("strong",[t._v("长度")]),t._v("。因此，"),a("code",[t._v("String")]),t._v("对象本身长度总是固定的三个字(word)。")]),t._v(" "),a("p",[t._v("如果我们只是对存储在"),a("code",[t._v("my_name")]),t._v("中的last name感兴趣，我们可以像下面这样来获取一个针对字符串中的特定部分的引用:")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" my_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Pascal"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("to_string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nmy_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_str")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('" Precht"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" last_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("my_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v('通过指定从第7个字节(因为有空格)开始一直到缓冲区的结尾("..")，'),a("code",[t._v("last_name")]),t._v("现在是一个引用自"),a("code",[t._v("my_name")]),t._v("拥有的文本的字符串切片(string slice)。它借用了这个文本。这里是它在内存中的样子:")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("my_name: String   last_name: &amp;str\n            [––––––––––––]    [–––––––]\n            +–––+––––+––––+–––+–––+–––+\nstack frame │ • │ 16 │ 13 │   │ • │ 6 │ \n            +–│–+––––+––––+–––+–│–+–––+\n              │                 │\n              │                 +–––––––––+\n              │                           │\n              │                           │\n              │                         [–│––––––– str –––––––––]\n            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+\n")])])]),a("p",[t._v("注意"),a("code",[t._v("last_name")]),t._v("没有在栈上存储容量信息。这是因为它只是对一个字符串切片的引用，而该字符串管理它的容量。这个字符串切片，即"),a("code",[t._v("str")]),t._v("本身，是不确定大小(unsized)的。 而且，在实际使用中，字符串切片总是以引用的形式出现，也就是它们的类型总是"),a("code",[t._v("&str")]),t._v("而不是"),a("code",[t._v("str")]),t._v("。")]),t._v(" "),a("p",[t._v("有两种情况我们需要使用字符串切片：要么创建一个对子字符串的引用，或者我们使用"),a("strong",[t._v("字符串字面量")]),t._v("(string literals)。")]),t._v(" "),a("p",[t._v("一个字符串字面量由一串被双引号包含的文本创建，就像这样：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" my_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Pascal Precht"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This is a `&str` not a `String`")]),t._v("\n")])])]),a("p",[t._v("下一个问题是，如果"),a("code",[t._v("&str")]),t._v("是一个引用了被(某人)拥有的"),a("code",[t._v("String")]),t._v("的切片，假定这个文本在适当的地方被创建，那么这么"),a("code",[t._v("String")]),t._v("的所有者是谁？")]),t._v(" "),a("p",[t._v("很显然，字符串字面量有点特殊。他们是引用自“预分配文本(preallocated text)”的字符串切片，这个预分配文本存储在可执行程序的只读内存中。换句话说，这是装载我们程序的内存并且不依赖于在堆上分配的缓冲区。")]),t._v(" "),a("p",[t._v("也就是说，栈上还有一个入口，指向当程序执行时预分配的内存。")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("my_name: &amp;str\n            [–––––––––––]\n            +–––+–––+\nstack frame │ • │ 6 │ \n            +–│–+–––+\n              │                 \n              +––+                \n                 │\n preallocated  +–V–+–––+–––+–––+–––+–––+\n read-only     │ P │ a │ s │ c │ a │ l │\n memory        +–––+–––+–––+–––+–––+–––+\n")])])]),a("p",[t._v("当我们对"),a("code",[t._v("String")]),t._v("和"),a("code",[t._v("&str")]),t._v("的区别有了更好的理解之后，另一个问题也就随之而来了。")]),t._v(" "),a("h3",{attrs:{id:"应该使用哪一个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应该使用哪一个"}},[t._v("#")]),t._v(" 应该使用哪一个？")]),t._v(" "),a("p",[t._v("显然，这取决于很多因素，但是一般地，保守来讲，如果我们正在构建的API不需要拥有或者修改使用的文本，那么应该使用"),a("code",[t._v("&str")]),t._v("而不是"),a("code",[t._v("String")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"life-time"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#life-time"}},[t._v("#")]),t._v(" Life Time")]),t._v(" "),a("p",[t._v("仅在编译期存在，与运行无关")]),t._v(" "),a("p",[t._v("生命周期参数类似模板参数，可以任意指定名称，除了保留的 "),a("code",[t._v("'static")])]),t._v(" "),a("p",[t._v("当生命周期的名称不重要的时候，可以使用 "),a("code",[t._v("'_")]),t._v(" 代表一个不具名的生命周期参数。")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Config")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("App")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    config"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Config")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("如果像上面这么直接用一个引用，无法通过编译，需要提供一个具名生命周期参数，如下")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("App")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    config"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Config")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("当提供了这样一个生命周期后，编译器可以保证引用类型 "),a("code",[t._v("&Config")]),t._v(" 变量 "),a("code",[t._v("config")]),t._v(" 和 "),a("code",[t._v("App")]),t._v(" 具有相同的生命周期，所以不会出现野指针。即编译器会根据编程者对生命周期的描述，进行检查保证引用都会在声明周期之内。")]),t._v(" "),a("p",[t._v("回顾所有权的定义，在变量超出所有权上下文后，就会被自动 drop 掉，对于引用也是如此")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        r "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"{}"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("该程序会报错 x 的生命周期不够长，在被 drop 后，r 仍然持有对 x 的引用。")]),t._v(" "),a("h3",{attrs:{id:"引用传参"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用传参"}},[t._v("#")]),t._v(" 引用传参")]),t._v(" "),a("p",[t._v("当传递引用时")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("some_function")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("some_function")]),t._v(" 接收一个对于"),a("code",[t._v("i32")]),t._v(" 类型的引用，随便给了一个生命周期参数"),a("code",[t._v("'a")]),t._v("。于是编译器就知道"),a("code",[t._v("some_function")]),t._v(" 不会也不应该去把 "),a("code",[t._v("val")]),t._v(" 存储到任何一个可能超出该函数生命周期的地方。")]),t._v(" "),a("p",[t._v("如果 "),a("code",[t._v("some_function")]),t._v(" 采用生命周期参数"),a("code",[t._v("'static")]),t._v("就不同了，Rust 会认为该参数是一个全局变量。这种情况下，只有"),a("code",[t._v("static")]),t._v(" 变量才能作为函数参数。")]),t._v(" "),a("h3",{attrs:{id:"返回引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#返回引用"}},[t._v("#")]),t._v(" 返回引用")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("smallest_number")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" s "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" r "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" r "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" s "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            s "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    s\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("上面的生命周期标识表明返回值和参数的生命周期是相同的，在调用函数处，如果输入参数的生命周期结束了，返回值也就不能再被引用了。事实上，上面的代码中不显式地标明生命周期参数也可以，编译器会自动完成推导。")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" numbers "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    s "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("smallest_number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("numbers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"{}"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("也就是说，这段代码会报错，因为在括号外，"),a("code",[t._v("numbers")]),t._v("  被 drop 掉了，所以 "),a("code",[t._v("s")]),t._v("也就无法引用函数返回值了。")]),t._v(" "),a("h3",{attrs:{id:"结构体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构体"}},[t._v("#")]),t._v(" 结构体")]),t._v(" "),a("p",[t._v("也就是一开始的那段代码。为什么编译器不能自动帮我们拓展一下生命周期？事实上在早期的编译器实现中，确实是这么干的，但是开发者发现有时会引发歧义，不如明确标识出引用的生命周期。")]),t._v(" "),a("p",[t._v("需要注意的是，当前面代码中的 "),a("code",[t._v("App")]),t._v("结构体被其他类型借用时，也需要提供生命周期参数，即")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Platform")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    app"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("App")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"多个生命周期参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个生命周期参数"}},[t._v("#")]),t._v(" 多个生命周期参数")]),t._v(" "),a("p",[t._v("考虑下面两种定义，第二种才是符合调用时要求的定义")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// The same lifetime annotation")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Point")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// Different lifetime annotation")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Point")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'b")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[t._v("'b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" point "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("y "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        r "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" point"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"{}"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在第一种定义下，编译器会自动选择更短的生命周期，即成员"),a("code",[t._v("x")]),t._v(" 和 "),a("code",[t._v("y")]),t._v(" 都会被当做 "),a("code",[t._v("y")]),t._v(" 的生命周期。")]),t._v(" "),a("h2",{attrs:{id:"trait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trait"}},[t._v("#")]),t._v(" Trait")]),t._v(" "),a("ul",[a("li",[t._v("Trait 比较烦的一点是在使用相关的类的时候，记得把它实现的 trait 也要 use 到。")]),t._v(" "),a("li",[t._v("递归相关的 trait、复制相关的 trait 遇到问题可以回顾过往的笔记。")])]),t._v(" "),a("h2",{attrs:{id:"与-c-结合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与-c-结合"}},[t._v("#")]),t._v(" 与 C++ 结合")]),t._v(" "),a("p",[t._v("标准库中几个常用的")]),t._v(" "),a("ul",[a("li",[t._v("std::os::raw")]),t._v(" "),a("li",[t._v("std::ffi")])]),t._v(" "),a("p",[t._v("http://crates.io/ 上的库")]),t._v(" "),a("ul",[a("li",[t._v("clib")]),t._v(" "),a("li",[t._v("inx")])]),t._v(" "),a("p",[a("code",[t._v("std::io::Error::last_os_error")]),t._v(" 这个函数，是用来捕获函数操作失败后，内核反馈给我们的错误。")]),t._v(" "),a("h2",{attrs:{id:"杂项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#杂项"}},[t._v("#")]),t._v(" 杂项")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("关键字 "),a("code",[t._v("ref")]),t._v("，"),a("code",[t._v("deref")]),t._v(" 等价于 "),a("code",[t._v("&")]),t._v(" 和 "),a("code",[t._v("*")]),t._v("，即")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3u8")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ref")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3u8")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("assert_eq!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("2018 版里，不用 "),a("code",[t._v("extern crate")]),t._v(" 了，可以直接 "),a("code",[t._v("use")])])])]),t._v(" "),a("h2",{attrs:{id:"安全性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全性"}},[t._v("#")]),t._v(" 安全性")]),t._v(" "),a("blockquote",[a("p",[t._v("If it compiles, then it works.")])]),t._v(" "),a("h3",{attrs:{id:"c-的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c-的情况"}},[t._v("#")]),t._v(" C++的情况")]),t._v(" "),a("p",[t._v("C++把内存使用分为两种情况：值对象和指针对象。值语义的对象超出作用域会自动调用析构函数销毁，传递或者赋值的时候会进行一次拷贝。指针语义则交给人肉来管理，或者使用智能指针来引用计数。值对象在传递赋值中拷贝一次比较浪费，所以C++后来有了移动构造函数。值在移动以后，关联的数据移动到新值。")]),t._v(" "),a("h3",{attrs:{id:"rust是怎么做的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rust是怎么做的"}},[t._v("#")]),t._v(" Rust是怎么做的")]),t._v(" "),a("p",[t._v("Rust则是在C++的基础上进一步优化。Rust的对象有一个所有者，和多个引用。Rust只允许值有一个所有者，传递和赋值会导致所有权移动。这看起来像C++的 "),a("code",[t._v("unique_ptr")]),t._v("，但实际上更像C++的移动语义。也就是说C++拷贝是隐式的移动是显式的，Rust移动是隐式的。当然Rust在这里有编译器的静态分析，没有运行时开销。很多地方并不想移动值，只是借用一下，Rust也使用了引用的概念，来表达指针语义。一个常见内存问题是指针指向了一个无效的内存地址，Rust却没这个问题。Rust编译器强制让你证明值的生命周期大于它的引用的生命周期。有些编译器搞不清楚的地方需要添加生命周期标记，来告诉编译器。")]),t._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[t._v("#")]),t._v(" References")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.thoughtram.io/string-vs-str-in-rust/",target:"_blank",rel:"noopener noreferrer"}},[t._v("String vs str in Rust"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/61652809",target:"_blank",rel:"noopener noreferrer"}},[t._v("知乎专栏：使用套接字联网 API"),a("OutboundLink")],1)]),t._v(" "),a("Comment",{attrs:{lang:"zh-CN"}})],1)}),[],!1,null,null,null);s.default=e.exports}}]);