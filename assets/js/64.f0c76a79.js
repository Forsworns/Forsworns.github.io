(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{482:function(a,t,s){"use strict";s.r(t);var e=s(12),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#伪目标-phony-target"}},[a._v("伪目标 Phony Target")])]),s("li",[s("a",{attrs:{href:"#预定义的变量"}},[a._v("预定义的变量")])]),s("li",[s("a",{attrs:{href:"#默认cc"}},[a._v("默认CC")])]),s("li",[s("a",{attrs:{href:"#内存泄漏检测"}},[a._v("内存泄漏检测")])]),s("li",[s("a",{attrs:{href:"#代码覆盖率"}},[a._v("代码覆盖率")])]),s("li",[s("a",{attrs:{href:"#为目录下所有文件生成目标代码"}},[a._v("为目录下所有文件生成目标代码")])]),s("li",[s("a",{attrs:{href:"#特殊符号"}},[a._v("特殊符号")])]),s("li",[s("a",{attrs:{href:"#赋值符号"}},[a._v("赋值符号")])]),s("li",[s("a",{attrs:{href:"#递归编译多目录"}},[a._v("递归编译多目录")])]),s("li",[s("a",{attrs:{href:"#编译时添加宏定义"}},[a._v("编译时添加宏定义")])]),s("li",[s("a",{attrs:{href:"#杂项"}},[a._v("杂项")])]),s("li",[s("a",{attrs:{href:"#指定安装目录"}},[a._v("指定安装目录")])]),s("li",[s("a",{attrs:{href:"#多级目录、多个链接库"}},[a._v("多级目录、多个链接库")])])])]),s("p"),a._v(" "),s("h1",{attrs:{id:"makefile-笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#makefile-笔记"}},[a._v("#")]),a._v(" Makefile 笔记")]),a._v(" "),s("p",[a._v("记录一些遇到的问题")]),a._v(" "),s("h2",{attrs:{id:"伪目标-phony-target"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#伪目标-phony-target"}},[a._v("#")]),a._v(" 伪目标 Phony Target")]),a._v(" "),s("p",[a._v("当目录下路径或文件与 Makefile中 的目标名冲突的时候，可以通过定义伪目标的方式避免冲突：")]),a._v(" "),s("p",[a._v("如下面这个例子")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("touch")]),a._v(" clean\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("make")]),a._v(" clean\n")])])]),s("p",[a._v("这样不会执行 Makefile 中定义的 clean 目标，而是会提示我们 "),s("code",[a._v("clean is up to date")])]),a._v(" "),s("p",[a._v("此时需要使用 "),s("code",[a._v(".PHONY")]),a._v(" 关键字来定义 clean")]),a._v(" "),s("p",[a._v("在 Makefile 中需要写")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v(".PHONY")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" clean\n")])])]),s("h2",{attrs:{id:"预定义的变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#预定义的变量"}},[a._v("#")]),a._v(" 预定义的变量")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("预定义变量")]),a._v(" "),s("th",[a._v("含义")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("AR")]),a._v(" "),s("td",[a._v("库文件维护程序的名称，默认值为ar")])]),a._v(" "),s("tr",[s("td",[a._v("AS")]),a._v(" "),s("td",[a._v("汇编程序的名称，默认值为as")])]),a._v(" "),s("tr",[s("td",[a._v("CC")]),a._v(" "),s("td",[a._v("C 编译器的名称，默认值为cc")])]),a._v(" "),s("tr",[s("td",[a._v("CPP")]),a._v(" "),s("td",[a._v("C 预编译器的名称，默认值为$(CC) –E")])]),a._v(" "),s("tr",[s("td",[a._v("CXX")]),a._v(" "),s("td",[a._v("C++编译器的名称，默认值为g++")])]),a._v(" "),s("tr",[s("td",[a._v("FC")]),a._v(" "),s("td",[a._v("FORTARAN 编译器的名称，默认值为f77")])]),a._v(" "),s("tr",[s("td",[a._v("RM")]),a._v(" "),s("td",[a._v("文件删除程序的名称，默认值为rm -f")])]),a._v(" "),s("tr",[s("td",[a._v("ARFLAGS")]),a._v(" "),s("td",[a._v("库文件维护程序的选项，无默认值")])]),a._v(" "),s("tr",[s("td",[a._v("ASFLAGS")]),a._v(" "),s("td",[a._v("汇编程序的选项，无默认值")])]),a._v(" "),s("tr",[s("td",[a._v("CFLAGS")]),a._v(" "),s("td",[a._v("C 编译器的选项，无默认值")])]),a._v(" "),s("tr",[s("td",[a._v("CPPFLAGS")]),a._v(" "),s("td",[a._v("C 预编译的选项，无默认值")])]),a._v(" "),s("tr",[s("td",[a._v("CXXFLAGS")]),a._v(" "),s("td",[a._v("C++编译器的选项，无默认值")])]),a._v(" "),s("tr",[s("td",[a._v("FFLAGS")]),a._v(" "),s("td",[a._v("Fortran 编译器的选项，无默认值")])])])]),a._v(" "),s("h2",{attrs:{id:"默认cc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#默认cc"}},[a._v("#")]),a._v(" 默认CC")]),a._v(" "),s("p",[a._v("在默认情况下，编译器使用 "),s("code",[a._v("cc")]),a._v("，可以通过"),s("code",[a._v("update-alternatives --list cc")]),a._v(" 命令查看安装的 C 编译器种类，然后使用 "),s("code",[a._v("update-alternatives --set cc")]),a._v(" 按照提示设置。")]),a._v(" "),s("h2",{attrs:{id:"内存泄漏检测"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏检测"}},[a._v("#")]),a._v(" 内存泄漏检测")]),a._v(" "),s("p",[a._v("之前用过 valgrind 工具辅助分析。还有一个比较好用的是 sanitize，可以在编译时作为 "),s("code",[a._v("CFLAGS")]),a._v(" 添加，比如使用 address 选项检测非法内存地址")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("ifeq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ASAN"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(",1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 需要定义该参数")]),a._v("\nCFLAGS "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" -fsanitize"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("address\nLDFLAGS "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" -fsanitize"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("address\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("endif")]),a._v("\n")])])]),s("p",[s("code",[a._v("-fsanitize=leak")]),a._v(" 则可以检查泄漏")]),a._v(" "),s("h2",{attrs:{id:"代码覆盖率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码覆盖率"}},[a._v("#")]),a._v(" 代码覆盖率")]),a._v(" "),s("p",[a._v("gcov是在代码运行时统计代码覆盖率的工具，随着gcc一起发布的。\n它的使用很简单，需要在编译和链接时增加-fprofile-arcs -ftest-coverage生成二进制文件。")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("ifeq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("COVERAGE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(",1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\nCFLAGS "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" -fprofile-arcs -ftest-coverage\nLDFLAGS "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" -fprofile-arcs\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("endif")]),a._v("\n")])])]),s("p",[a._v("gcov主要使用.gcno和.gcda两个文件。\n.gcno是由-ftest-coverage产生的，它包含了重建基本块图和相应的块的源码的行号的信息。\n.gcda是由加了-fprofile-arcs编译参数的编译后的文件运行所产生的，它包含了弧跳变的次数和其他的概要信息。")]),a._v(" "),s("h2",{attrs:{id:"为目录下所有文件生成目标代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为目录下所有文件生成目标代码"}},[a._v("#")]),a._v(" 为目录下所有文件生成目标代码")]),a._v(" "),s("p",[a._v("可以使用例如下面 Makefile 的写法，使用通配符")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[a._v("SOURCES "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("wildcard")]),a._v(" *.c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\nOBJS "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("patsubst")]),a._v(" %.c,%.o,"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SOURCES"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("All")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("OBJS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("h2",{attrs:{id:"特殊符号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特殊符号"}},[a._v("#")]),a._v(" 特殊符号")]),a._v(" "),s("p",[s("code",[a._v("$@")]),a._v(" 表示目标文件")]),a._v(" "),s("p",[s("code",[a._v("$^")]),a._v(" 表示所有的依赖文件")]),a._v(" "),s("p",[s("code",[a._v("$<")]),a._v(" 表示第一个依赖文件")]),a._v(" "),s("p",[s("code",[a._v("$?")]),a._v(" 表示比目标还要新的依赖文件列表")]),a._v(" "),s("p",[s("code",[a._v("$%")]),a._v(" 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"),s("code",[a._v("foo.a(bar.o)")]),a._v("，那么，"),s("code",[a._v("$%")]),a._v("就是"),s("code",[a._v("bar.o")]),a._v("，"),s("code",[a._v("$@")]),a._v("就是"),s("code",[a._v("foo.a")]),a._v("。如果目标不是函数库文件，那么，其值为空。")]),a._v(" "),s("p",[s("code",[a._v("$+")]),a._v(" 这个变量很像"),s("code",[a._v("$^")]),a._v("，也是所有依赖目标的集合。只是它不去除重复的依赖目标。")]),a._v(" "),s("p",[s("code",[a._v("$*")]),a._v(" 这个变量表示目标模式中 "),s("code",[a._v("%")]),a._v("及其之前的部分。如果目标是 "),s("code",[a._v("dir/a.foo.b")]),a._v("，并且目标的模式是"),s("code",[a._v("a.%.b")]),a._v("，那么，"),s("code",[a._v("$*")]),a._v("的值就是"),s("code",[a._v("dir/a.foo")]),a._v("。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么“*”也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么“*”就是除了后缀的那一部分。例如：如果目标是“foo.c”，因为“.c”是make所能识别的后缀名，所以，"),s("code",[a._v("$*")]),a._v("的值就是"),s("code",[a._v("foo")]),a._v("。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用"),s("code",[a._v("$*")]),a._v("，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么"),s("code",[a._v("$*")]),a._v("就是空值。")]),a._v(" "),s("h2",{attrs:{id:"赋值符号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#赋值符号"}},[a._v("#")]),a._v(" 赋值符号")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("=")]),a._v(" 是最基本的赋值")]),a._v(" "),s("li",[s("code",[a._v(":=")]),a._v(" 是覆盖之前的值")]),a._v(" "),s("li",[s("code",[a._v("?=")]),a._v(" 是如果没有被赋值过就赋予等号后面的值")]),a._v(" "),s("li",[s("code",[a._v("+=")]),a._v(" 是添加等号后面的值")])]),a._v(" "),s("h2",{attrs:{id:"递归编译多目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归编译多目录"}},[a._v("#")]),a._v(" 递归编译多目录")]),a._v(" "),s("p",[a._v("假设目标代码和可执行文件都在 "),s("code",[a._v("debug")]),a._v(" 目录下，其他都是源代码文件，则根目录下 Makefile")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#设置编译器")]),a._v("\nCC"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("gcc\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#debug文件夹里的makefile文件需要最后执行，所以这里需要执行的子目录要排除debug文件夹，这里使用awk排除了debug文件夹，读取剩下的文件夹")]),a._v("\nSUBDIRS"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("shell")]),a._v(" ls -l "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" grep ^d "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" awk "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'{if($$9 != \"debug\") print $$9}'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#无需下一行的注释代码，因为我们已经知道debug里的makefile是最后执行的，所以最后直接去debug目录下执行指定的makefile文件就行，具体下面有注释")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#DEBUG=$(shell ls -l | grep ^d | awk '{if($$9 == \"debug\") print $$9}')")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#记住当前工程的根目录路径")]),a._v("\nROOT_DIR"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("shell")]),a._v(" pwd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#最终bin文件的名字，可以更改为自己需要的")]),a._v("\nBIN"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("myapp\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#目标文件所在的目录")]),a._v("\nOBJS_DIR"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("debug/obj\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#bin文件所在的目录")]),a._v("\nBIN_DIR"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("debug/bin\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#获取当前目录下的c文件集，放在变量CUR_SOURCE中")]),a._v("\nCUR_SOURCE"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("wildcard *.c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#将对应的c文件名转为o文件后放在下面的CUR_OBJS变量中")]),a._v("\nCUR_OBJS"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("patsubst %.c, %.o, "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("CUR_SOURCE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#将以下变量导出到子shell中，本次相当于导出到子目录下的makefile中")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("export")]),a._v(" CC BIN OBJS_DIR BIN_DIR ROOT_DIR\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#注意这里的顺序，需要先执行SUBDIRS最后才能是DEBUG")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("all")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SUBDIRS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("CUR_OBJS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" DEBUG\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#递归执行子目录下的makefile文件，这是递归执行的关键")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),a._v("(SUBDIRS)")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("ECHO\n    make -C "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$@")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("DEBUG")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("ECHO\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#直接去debug目录下执行makefile文件")]),a._v("\n    make -C debug\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("ECHO")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("@")]),a._v("echo "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SUBDIRS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#将c文件编译为o文件，并放在指定放置目标文件的目录中即OBJS_DIR")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),a._v("(CUR_OBJS)")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("%.o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("%.c\n    "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("CC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" -c "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$^")]),a._v(" -o "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ROOT_DIR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("/"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("OBJS_DIR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("/"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$@")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("CLEAN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("@")]),a._v("rm "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("OBJS_DIR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("/*.o\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("@")]),a._v("rm -rf "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("BIN_DIR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("/*\n")])])]),s("p",[a._v("子目录 makefile")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#子目录的Makefile直接读取其子目录就行，使用 grep 过滤出来目录（ls 后会以d为标识开头）")]),a._v("\nSUBDIRS"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("shell")]),a._v(" ls -l "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" grep ^d "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" awk "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'{print $$9}'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#以下同根目录下的makefile的相同代码的解释")]),a._v("\nCUR_SOURCE"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("wildcard *.c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\nCUR_OBJS"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("patsubst %.c, %.o, "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("CUR_SOURCE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("ALL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SUBDIRS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("CUR_OBJS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),a._v("(SUBDIRS)")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("ECHO\n    make -C "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$@")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),a._v("(CUR_OBJS)")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("%.o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("%.c\n    "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("CC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" -c "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$^")]),a._v(" -o "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ROOT_DIR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("/"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("OBJS_DIR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("/"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$@")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("ECHO")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("@")]),a._v("echo "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SUBDIRS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("生成的目标文件和可执行文件目录"),s("code",[a._v("debug")]),a._v("下 makefile")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[a._v("OBJS"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("*.o\nODIR"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("obj\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),a._v("(ROOT_DIR)/"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),a._v("(BIN_DIR)/"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),a._v("(BIN)")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ODIR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("/"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("OBJS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("CC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" -o "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$@")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$^")]),a._v("\n")])])]),s("h2",{attrs:{id:"编译时添加宏定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译时添加宏定义"}},[a._v("#")]),a._v(" 编译时添加宏定义")]),a._v(" "),s("p",[a._v("假设代码如下，检查是否存在")]),a._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// test.c")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[a._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[a._v("include")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("<stdio.h>")]),a._v("  ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[a._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[a._v("include")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("<stdlib.h>")]),a._v("  ")]),a._v("\n  \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" argc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" argv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n      \n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[a._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[a._v("ifndef")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[a._v("A_MACRO")])]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[a._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[a._v("endif")]),a._v("  ")]),a._v("\n  \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("命令行直接使用 gcc 编译时，可以传递 "),s("code",[a._v("-D")]),a._v(" 参数来定义")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("gcc test.c -D A_MACRO\n")])])]),s("p",[a._v("在 Makefile 中，当然可以在 gcc 后面写 -D，也可以直接加在 "),s("code",[a._v("CFLAGS")]),a._v(" 中，同时也可以用下面的方式给 make 传递参数决定是否定义该宏")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[a._v("MACROS"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("\nCFLAGS"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("-g "),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("MACROS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("all")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("a.out\ng++ CFLAGS -o a.out\n")])])]),s("p",[a._v("使用 make 时，便可以这样写")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("make")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DEBUG")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'-D A_MACRO'")]),a._v("\n")])])]),s("h2",{attrs:{id:"杂项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#杂项"}},[a._v("#")]),a._v(" 杂项")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("当没有指明目标时，make 默认执行 Makefile 中定义的第一个目标，也称为默认目标")])]),a._v(" "),s("li",[s("p",[a._v("在 Makefile 中，使用 "),s("code",[a._v("@echo")]),a._v(" 可以执行 "),s("code",[a._v("echo")]),a._v(" 命令")])]),a._v(" "),s("li",[s("p",[a._v("在 Makefile 中，目标后可以添加其他目标，表示依赖关系，即当前目标需要这些目标作为支持，会先构建依赖着的其他目标，再执行剩下的命令，即基本语法是")]),a._v(" "),s("div",{staticClass:"language-makefile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-makefile"}},[s("code",[s("span",{pre:!0,attrs:{class:"token symbol"}},[a._v("target")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" prerequisites\n\tcommand\n")])])])]),a._v(" "),s("li",[s("p",[a._v("直接使用 "),s("code",[a._v("=")]),a._v(" 就可以在 Makefile 中定义变量如 "),s("code",[a._v("CC = gcc")]),a._v("，使用 "),s("code",[a._v("$(CC)")]),a._v(" 可以读取它")])])]),a._v(" "),s("h1",{attrs:{id:"cmake-笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cmake-笔记"}},[a._v("#")]),a._v(" cmake 笔记")]),a._v(" "),s("p",[a._v("使用 cmake 读取 CMakeList.txt 可以自动生成需要的 Makefile。CMakeList 的语法：")]),a._v(" "),s("h2",{attrs:{id:"指定安装目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指定安装目录"}},[a._v("#")]),a._v(" 指定安装目录")]),a._v(" "),s("p",[a._v("通过定义 "),s("code",[a._v("CMAKE_INSTALL_PREFIX:PATH")]),a._v(" 更改安装路径，在无法获取 sudo 权限时候可以使用这种方式安到当前用户目录下？")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("mkdir")]),a._v(" build\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("cd")]),a._v(" build\ncmake -DCMAKE_INSTALL_PREFIX:"),s("span",{pre:!0,attrs:{class:"token environment constant"}},[a._v("PATH")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$(")]),a._v("realpath "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("/install"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v(")")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("make")]),a._v(" -j N "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v("\n")])])]),s("p",[a._v("例如这个例子中，通过 "),s("code",[a._v("realpath")]),a._v(" 获取相对路径的绝对路径名，从而安装在上级的 install 目录下")]),a._v(" "),s("h2",{attrs:{id:"多级目录、多个链接库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多级目录、多个链接库"}},[a._v("#")]),a._v(" 多级目录、多个链接库")]),a._v(" "),s("p",[a._v("例如这里我有一个")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(".")]),a._v("\n├── main.c\n├── first.c\n├── first.h\n└── second\n")])])]),s("p",[a._v("这样的文件目录，怎么在根目录下构建 "),s("code",[a._v("main.c")]),a._v(" 呢？同时依赖于 "),s("code",[a._v("first.c")]),a._v(" 文件和 "),s("code",[a._v("second")]),a._v(" 目录下的两个库（均为 C 实现），同时 "),s("code",[a._v("first.c")]),a._v(" 又依赖于 "),s("code",[a._v("second")]),a._v("目录下的库。")]),a._v(" "),s("p",[a._v("在根目录下，编写")]),a._v(" "),s("div",{staticClass:"language-cmake extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cmake"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("cmake_minimum_required")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token property"}},[a._v("VERSION")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3.10.2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("project")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("laser"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("CMAKE_C_FLAGS")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("${")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("CMAKE_C_FLAGS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")])]),a._v(' -Wall"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("add_definitions")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("-DENABLE_DBG"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# second lib")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("add_subdirectory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("second"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# add this directory to project, traverse it, and apply the `CMakeLists.txt` inside it")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("list")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("APPEND EXTRA_INCLUDES "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("${")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("PROJECT_SOURCE_DIR")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")])]),a._v('/second"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("set_target_properties")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("second "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("PROPERTIES")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token property"}},[a._v("LINKER_LANGUAGE")]),a._v(" C"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# lib for first main logic")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("add_library")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("first first.c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("target_link_libraries")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("first second"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# built target for `first` lib would be dependent on on second lib")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("target_include_directories")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("first "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("PUBLIC")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("${")]),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("PROJECT_BINARY_DIR")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("${")]),a._v("EXTRA_INCLUDES"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# the headers in the second lib would be added to include path, so that we do not need to configure relative paths when include them in codes")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# main executable file")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SRC_LIST main.c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("add_executable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("laser "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("${")]),a._v("SRC_LIST"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("target_link_libraries")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("laser first"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# or target_link_libraries(laser first second), up to your requirements on second lib")]),a._v("\n")])])]),s("p",[a._v("对 first 和 second 两个库和 main.c 对应的代码都构建编译 target，通过 "),s("code",[a._v("target_link_libraries")]),a._v(" 去声明依赖关系，这样会自动先编译 second 库，再编译 first 库，把 second 库链接给它，再链接 first 库编译 main.c 对应的可执行文件。使用 cmake 就是一个声明依赖关系的过程，而且很多步骤 cmake 都会自动帮忙干。")]),a._v(" "),s("p",[a._v("那么在 second 目录下，还需要加一个，定义一个名为 second 的库，并用 "),s("code",[a._v("file()")]),a._v(" 函数方便地选取目录下所有文件")]),a._v(" "),s("div",{staticClass:"language-cmake extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cmake"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("file")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("GLOB "),s("span",{pre:!0,attrs:{class:"token property"}},[a._v("SOURCES")]),a._v(" *.c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("file")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("GLOB HEADERS *.h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("add_library")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("second "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("${")]),s("span",{pre:!0,attrs:{class:"token property"}},[a._v("SOURCES")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("${")]),a._v("HEADERS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("h1",{attrs:{id:"reference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[a._v("#")]),a._v(" Reference")]),a._v(" "),s("p",[s("a",{attrs:{href:"http://www.gnu.org/software/make/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Make - GNU Project - Free Software Foundation"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/seisman/how-to-write-makefile",target:"_blank",rel:"noopener noreferrer"}},[a._v("seisman/how-to-write-makefile: 跟我一起写Makefile重制版 (github.com)"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/u014470361/article/details/103447678",target:"_blank",rel:"noopener noreferrer"}},[a._v("gcc编译选项-fprofile-arcs -ftest-coverage之代码覆盖率_夜风的博客-CSDN博客"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/Shirlies/p/4282182.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("多文件目录下makefile文件递归执行编译所有c文件 - Shirlies - 博客园 (cnblogs.com)"),s("OutboundLink")],1)]),a._v(" "),s("Comment",{attrs:{lang:"zh-CN"}})],1)}),[],!1,null,null,null);t.default=n.exports}}]);