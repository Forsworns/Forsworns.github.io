(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{506:function(t,s,a){"use strict";a.r(s);var e=a(12),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#教程的简介"}},[t._v("教程的简介")])]),a("li",[a("a",{attrs:{href:"#advance03-示例的笔记"}},[t._v("Advance03 示例的笔记")]),a("ul",[a("li",[a("a",{attrs:{href:"#af-xdp-的性能提升从何而来"}},[t._v("AF_XDP 的性能提升从何而来？")])]),a("li",[a("a",{attrs:{href:"#示例代码阅读"}},[t._v("示例代码阅读")])]),a("li",[a("a",{attrs:{href:"#可能碰到的问题"}},[t._v("可能碰到的问题")])]),a("li",[a("a",{attrs:{href:"#zero-copy-模式"}},[t._v("zero-copy 模式")])]),a("li",[a("a",{attrs:{href:"#在-stm32mp157a-开发板上跑这个-demo-碰到的问题"}},[t._v("在 STM32MP157A 开发板上跑这个 demo 碰到的问题")])])])]),a("li",[a("a",{attrs:{href:"#其他可以参考的资料"}},[t._v("其他可以参考的资料")])])])]),a("p"),t._v(" "),a("h1",{attrs:{id:"xdp-tutorial-学习笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xdp-tutorial-学习笔记"}},[t._v("#")]),t._v(" XDP Tutorial 学习笔记")]),t._v(" "),a("p",[t._v('xdp 的相关论文发在 2018 年 CONEXT 上，文章名称是 "The eXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel"，是 OA 的，可以直接'),a("a",{attrs:{href:"https://dl.acm.org/doi/10.1145/3281411.3281443",target:"_blank",rel:"noopener noreferrer"}},[t._v("下载来看"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("学习一下 xdp 官方提供的教程，项目地址额为 "),a("a",{attrs:{href:"https://github.com/xdp-project/xdp-tutorial",target:"_blank",rel:"noopener noreferrer"}},[t._v("xdp-project/xdp-tutorial: XDP tutorial"),a("OutboundLink")],1),t._v("。该教程依赖的 libbpf 是19年的一版，直接用新版会有问题，需要下项目里的子模块指定的 "),a("a",{attrs:{href:"https://github.com/libbpf/libbpf/tree/b91f53ec5f1aba2a9d01dc00c4434063abd921e8",target:"_blank",rel:"noopener noreferrer"}},[t._v("libbpf/libbpf at b91f53ec5f1aba2a9d01dc00c4434063abd921e8"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"教程的简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#教程的简介"}},[t._v("#")]),t._v(" 教程的简介")]),t._v(" "),a("p",[t._v("比较基础的章节是 "),a("code",[t._v("basic01")]),t._v(" 到 "),a("code",[t._v("basic04")]),t._v(" 目录下的内容。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("basic02")]),t._v("：讲解了 libbpf 怎么加载 bpf 代码的。让读者自己实现一个简化的加载过程。用户实现的函数，使用 "),a("code",[t._v("_")]),t._v(" 前缀与教程中 xdp 团队提供的 api 相区分。相应的 api 是没有 "),a("code",[t._v("_")]),t._v(" 前缀的，位于 "),a("code",[t._v("common")]),t._v(" 目录下。例如，"),a("code",[t._v("common/common_user_bpf_xdp.c")]),t._v(" 下的"),a("code",[t._v("load_bpf_and_xdp_attach()")]),t._v(" 函数。")]),t._v(" "),a("li",[a("code",[t._v("basic03")]),t._v("：讲解了 bpf map 的使用。")]),t._v(" "),a("li",[a("code",[t._v("basic04")]),t._v("：讲解了跨应用共享 bpf map，使用的是 pinning maps 技术。")])]),t._v(" "),a("p",[a("code",[t._v("tracing01")]),t._v(" 到 "),a("code",[t._v("tracing04")]),t._v(" 是做 tracing 方面的应用。")]),t._v(" "),a("p",[a("code",[t._v("packet01")]),t._v(" 到 "),a("code",[t._v("packet03")]),t._v(" 是从包的层面上做了 parsing、rewriting、redirecting。")]),t._v(" "),a("p",[a("code",[t._v("advance01")]),t._v(" 是 xdp 和 tc 交互的例子。")]),t._v(" "),a("p",[a("code",[t._v("advance03")]),t._v(" 很有趣，是一个比较完整的例子，展示了如何通过 xdp 在用户空间解析 IPV6 ICMP 报文，并发送回复。是用了一种新型的 socket 地址类型，"),a("code",[t._v("AF_XDP")]),t._v("，可以在 kernel 的文档中找到"),a("a",{attrs:{href:"https://www.kernel.org/doc/html/latest/networking/af_xdp.html",target:"_blank",rel:"noopener noreferrer"}},[t._v(" AF_XDP 的介绍"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("这些教程中的 Assignment 的答案分布："),a("code",[t._v("advance")]),t._v(" 和 "),a("code",[t._v("tracing")]),t._v(" 部分的答案就是在代码里的。"),a("code",[t._v("basic")]),t._v(" 和 "),a("code",[t._v("packet")]),t._v(" 部分的是在 "),a("code",[t._v("basic-solutions")]),t._v(" 和"),a("code",[t._v("packet-solutions")]),t._v(" 目录下。")]),t._v(" "),a("h2",{attrs:{id:"advance03-示例的笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#advance03-示例的笔记"}},[t._v("#")]),t._v(" Advance03 示例的笔记")]),t._v(" "),a("p",[t._v("xdp 没有完全绕过内核，但是可以让包跳过内核的网络栈，直接从用户空间读取，可以通过 "),a("code",[t._v("AF_XDP")]),t._v(" 的 "),a("code",[t._v("XDP_REDIRECT")]),t._v(" 语义实现。")]),t._v(" "),a("p",[t._v("首先简要记录一下 "),a("code",[t._v("AF_XDP")]),t._v(" 套接字。"),a("code",[t._v("AF_XDP")]),t._v(" socket， 缩写为 XSK，可以通过系统调用 "),a("code",[t._v("socket()")]),t._v(" 创建。每个 XSK 都有两个环来存储数据，一个 RX ring 和一个 TX ring。套接字能够用 RX ring 接收包，通过 TX ring 发送包。这些环是通过 "),a("code",[t._v("setsockopts")]),t._v(" 中的选项 "),a("code",[t._v("XDP_RX_RING")]),t._v(" 和 "),a("code",[t._v("XDP_TX_RING")]),t._v(" 设置的。每个套接字至少需要其中的一个（以作为单侧的 source/sink node）。RX/TX ring 指向内存中一块叫做 UMEM 的数据。RX 和 TX 能够共享同一块 UMEM 区域，以防在 RX 和 TX 之间频繁地进行数据拷贝。另外，如果由于潜在的重传，一个包需要被保存一段时间，这些指针也能暂时指向别的包，避免拷贝数据。")]),t._v(" "),a("p",[t._v("在 BPF 侧的 AF_XDP 程序，参数是 "),a("code",[t._v("struct xdp_md")]),t._v("，包含原始 frame 的数据。可以返回一些状态来表示对该 frame 的处理意见，比如：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("XDP_PASS")]),t._v("：继续传递到 Linux 后续的协议栈中处理。")]),t._v(" "),a("li",[a("code",[t._v("XDP_REDIRECT")]),t._v("：将包通过 UMEM 传递到用户空间处理。")]),t._v(" "),a("li",[a("code",[t._v("XDP_DROP")]),t._v("：直接丢弃这个包。")]),t._v(" "),a("li",[a("code",[t._v("XDP_TX")]),t._v(" 可以直接发回给网卡，可以用来在内核中做快速的回复。比如下面 Advance03 中做的事情，去交换 ICMP 报文的发送方和接收方。该例子其实可以在内核中完成，然后用 "),a("code",[t._v("XDP_TX")]),t._v(" 发回去，不是必须 redirect 到用户空间再做。")])]),t._v(" "),a("h3",{attrs:{id:"af-xdp-的性能提升从何而来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#af-xdp-的性能提升从何而来"}},[t._v("#")]),t._v(" AF_XDP 的性能提升从何而来？")]),t._v(" "),a("p",[t._v("AF_XDP socket 非常快，在这个性能提升的背后隐藏了多少秘密呢？ AF_XDP 的 idea 背后的基础可以追溯到 "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Van_Jacobson",target:"_blank",rel:"noopener noreferrer"}},[t._v("Van Jacobson"),a("OutboundLink")],1),t._v(" 的关于 "),a("a",{attrs:{href:"https://lwn.net/Articles/169961/",target:"_blank",rel:"noopener noreferrer"}},[t._v("network channels"),a("OutboundLink")],1),t._v(" 的报告中。在该报告中，描述了如何直接从驱动的 RX-queue （接收队列）去创建一个无锁的 "),a("a",{attrs:{href:"https://lwn.net/Articles/169961/",target:"_blank",rel:"noopener noreferrer"}},[t._v("channel"),a("OutboundLink")],1),t._v(" 构建 AF_XDP socket。")]),t._v(" "),a("p",[t._v("（前面介绍 "),a("code",[t._v("AF_XDP")]),t._v(" 的内容也提到了），AF_XDP 使用的队列是 Single-Producer/Single-Consumer (SPSC) 的描述符（descriptor）环形队列：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("Single-Producer")]),t._v(" (SP) 绑定到了某个特定的 RX "),a("strong",[t._v("queue id")]),t._v(" 上，通过 NAPI-softirq 确保在软中断（softirq）触发期间，只有一个 CPU 来处理一个 RX-queue id。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("NAPI 是 Linux 上采用的一种提高网络处理效率的技术，它的核心概念就是不采用中断的方式读取数据，否则包太多了，不停触发中断。而代之以首先采用中断唤醒数据接收的服务程序，然后 POLL 的方法来轮询数据。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Single-Consumer")]),t._v(" (SC) 则是一个应用，从环中读取指向 UMEM 区域的描述符（descriptor）。")])])]),t._v(" "),a("p",[t._v("因此不需要对每个包都分配一次内存。可以在事先为 UMEM 内存区域进行分配（因此 UMEM 是有界的）。UMEM 包含了一些大小相同的块，环中的指针会引用它们的地址来引用这些块。这个地址就是在整个 UMEM 区域中的偏移量。用户空间负责为 UMEM 分配内存，分配的方法很灵活，可以用 malloc、mmap、huge pages 等形式。这个内存空间通过在 "),a("code",[t._v("setsockopt()")]),t._v(" 方法中设置 "),a("code",[t._v("XDP_UMEM_REG")]),t._v(" 触发相应的系统调用，注册到内核中。"),a("strong",[t._v("需要注意的是")]),t._v("：这样就意味着你需要负责及时地将 frame 返回给 UMEM，并且需要为你的应用提前分配足够的内存。")]),t._v(" "),a("p",[t._v("Van Jacobson 在报告中谈到的 "),a("a",{attrs:{href:"http://www.lemis.com/grog/Documentation/vj/lca06vj.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("transport signature"),a("OutboundLink")],1),t._v("，在 XDP/eBPF 程序中体现为选择将 frame "),a("code",[t._v("XDP_REDIRECT")]),t._v(" 到哪个 AF_XDP socket。")]),t._v(" "),a("h3",{attrs:{id:"示例代码阅读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例代码阅读"}},[t._v("#")]),t._v(" 示例代码阅读")]),t._v(" "),a("p",[t._v("打开 "),a("code",[t._v("advanced03-AF_XDP/af_xdp_kern.c")]),t._v("，它很精简，只有四十行代码。首先定义了两个 bpf map，一个存储 XSK，一个存储包的数量数据。然后定义了一个 bpf 程序，它的参数是 "),a("code",[t._v("struct xdp_md")]),t._v("，所以它是一个 "),a("strong",[t._v("BPF_PROG_TYPE_XDP")]),t._v(" 类型的 BPF 程序。这段程序通过 "),a("code",[t._v("SEC()")]),t._v(" 宏放在了"),a("code",[t._v("xdp_sock")]),t._v(" 段中，用 bpf helper 函数来和定义好的 bpf map 交互。注意其中的代码")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* We pass every other packet */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pkt_count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" XDP_PASS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("是间隔一个地直接返回 "),a("code",[t._v("XDP_PASS")]),t._v("，下一个包才会用 "),a("code",[t._v("bpf_redirect_map")]),t._v(" 去转发。也就是说，过滤掉了一半的包。")]),t._v(" "),a("p",[t._v("在用户空间代码 "),a("code",[t._v("advanced03-AF_XDP/af_xdp_user.c")]),t._v(" 中。首先是做了 bpf 用户空间程序必要的一些工作，比如 "),a("code",[t._v("setrlimit(RLIMIT_MEMLOCK, &rlim)")]),t._v(" 去释放内存限制。这也是为什么必须用 sudo 权限运行 bpf 程序。")]),t._v(" "),a("p",[t._v("用 "),a("code",[t._v("stats_record")]),t._v(" 结构体记录收发数量，在代码最后会单独开一个线程去调用 "),a("code",[t._v("stats_poll()")]),t._v(" 函数打印实时的收发数据，用信号 "),a("code",[t._v("signal(SIGINT, exit_application)")]),t._v(" 注册 "),a("code",[t._v("exit_application()")]),t._v(" 函数，在结束时设置变量，帮助 "),a("code",[t._v("stats_poll()")]),t._v(" 停止监测。")]),t._v(" "),a("p",[a("code",[t._v("xsk_socket_info")]),t._v(" 结构体包装 "),a("code",[t._v("xsk_socket")]),t._v("，"),a("code",[t._v("xsk_umem_info")]),t._v(" 结构体包装 "),a("code",[t._v("xsk_umem")]),t._v("。这部分代码会反复用到缩写 PROD 代表 producer，也就是发送端 tx；缩写 CONS 代表 consumer，也就是接收端 rx。因为 XSK 默认是 Single-Producer-Single-Consumer 的。")]),t._v(" "),a("p",[a("code",[t._v("xsk_configure_socket()")]),t._v(" 初始化了 XSK，注意这里初始化发送端和接收端时，是传设置项 "),a("code",[t._v("xsk_cfg")]),t._v(" 给库函数 "),a("code",[t._v("xsk_socket__create()")]),t._v("。"),a("code",[t._v("xsk_cfg.rx_size")]),t._v(" 和 "),a("code",[t._v("xsk_cfg.tx_size")]),t._v(" 分别初始化成了 "),a("code",[t._v("XSK_RING_CONS__DEFAULT_NUM_DESCS")]),t._v(" 和 "),a("code",[t._v("XSK_RING_PROD__DEFAULT_NUM_DESCS")]),t._v("，他们会在库函数 "),a("code",[t._v("xsk_socket__create()")]),t._v(" 中传递给系统调用 "),a("code",[t._v("setsockopt()")]),t._v(" 去完成 XSK 中的 tx 和 rx 的创建。他们是定义在 "),a("code",[t._v("xsk.h")]),t._v(" 中的宏，值都是 2048。事实上，只能被初始化成2的幂次。因为在库里的 "),a("code",[t._v("xsk.h")]),t._v(" 中，获取 "),a("code",[t._v("xdp_desc")]),t._v(" 的函数是这么定义的")]),t._v(" "),a("div",{staticClass:"language-C extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xdp_desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("xsk_ring_prod__tx_desc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xsk_ring_prod")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t\t\t\t\t      __u32 idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xdp_desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("descs "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xdp_desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("tx"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("descs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("idx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" tx"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("mask"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xdp_desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("xsk_ring_cons__rx_desc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xsk_ring_cons")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" __u32 idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xdp_desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("descs "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xdp_desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("rx"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("descs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("idx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" rx"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("mask"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Rx/Tx descriptor */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xdp_desc")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t__u64 addr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t__u32 len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t__u32 options"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("注意 "),a("code",[t._v("idx & tx->mask")]),t._v(" 和  "),a("code",[t._v("idx & rx->mask")]),t._v(" 是在用按位与运算去防止下标溢出，相当于在取模。这里的 "),a("code",[t._v("mask")]),t._v(" 是在库里的 "),a("code",[t._v("xsk.c")]),t._v(" 中的"),a("code",[t._v("xsk_socket__create()")]),t._v(" 函数中初始化的，都是初始化成 "),a("code",[t._v("size-1")]),t._v(" 的，也就是 2047，各位都是 1，如果 "),a("code",[t._v("size")]),t._v(" 不是 2 的幂次，显然就不能这么干了。")]),t._v(" "),a("p",[t._v("创建好 XSK，就可以监听了，这部分逻辑写在 "),a("code",[t._v("rx_and_process()")]),t._v(" 中，用 "),a("code",[t._v("poll(struct pollfd *__fds, nfds_t __nfds, -1)")]),t._v(" 系统调用去监听之前创建好的 XSK，在没有触发事件时阻塞。收到包后，调用 "),a("code",[t._v("handle_receive_packets()")]),t._v(" 在 XSK 对应的 umem 中读取 rx 端，也就是 consumer 接收到的包。经过最深层的 "),a("code",[t._v("process_packet()")]),t._v(" 处理，做的就是把包的指针转换成各层的首部，然后读取他们。因为实验中只有 IPV6 ICMP 报文，所以就直接像下面这样写了。处理完后，写入到 umem 中 tx 也就是 producer 管理的内存中。")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" bool "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("process_packet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("xsk_socket_info")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("xsk"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint64_t")]),t._v(" addr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint32_t")]),t._v(" len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint8_t")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pkt "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("xsk_umem__get_data")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("xsk"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("umem"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("buffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" addr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// get header one by one")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ethhdr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("eth "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ethhdr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" pkt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// pointer adds 1*sizeof(ethhdr) in fact")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ipv6hdr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ipv6 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ipv6hdr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("eth "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// pointer adds 1*sizeof(ipv6hdr) in fact")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("icmp6hdr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("icmp "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("icmp6hdr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ipv6 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    \n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// exchange source and destination")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memcpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("tmp_mac"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" eth"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("h_dest"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ETH_ALEN"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memcpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("eth"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("h_dest"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" eth"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("h_source"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ETH_ALEN"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memcpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("eth"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("h_source"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tmp_mac"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ETH_ALEN"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n\n\ticmp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("icmp6_type "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ICMPV6_ECHO_REPLY"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// replace icmp checksum in the packet")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("csum_replace2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("icmp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("icmp6_cksum"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("htons")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ICMPV6_ECHO_REQUEST "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("htons")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ICMPV6_ECHO_REPLY "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// check remaining space in the ring ")]),t._v("\n\tret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("xsk_ring_prod__reserve")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("xsk"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("tx_idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* No more transmit slots, drop the packet */")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" false"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// write to tx")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("xsk_ring_prod__tx_desc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("xsk"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tx_idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("addr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" addr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("xsk_ring_prod__tx_desc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("xsk"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tx_idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("len "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("xsk_ring_prod__submit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("xsk"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" true"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("至此该节内容结束。")]),t._v(" "),a("h3",{attrs:{id:"可能碰到的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可能碰到的问题"}},[t._v("#")]),t._v(" 可能碰到的问题")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("首先这些 BPF 相关的 demo 都是需要 "),a("code",[t._v("sudo")]),t._v(" 去跑的，需要管理员权限。")])]),t._v(" "),a("li",[a("p",[t._v("系统内核太旧了，本身不支持 "),a("code",[t._v("AF_XDP")]),t._v(" socket。")])]),t._v(" "),a("li",[a("p",[t._v("最常见的错误：为什么我在 AF_XDP socket 上看不到任何流量？")]),t._v(" "),a("p",[t._v("正如你在上面了解到的，AF_XDP socket 绑定到了一个 "),a("strong",[t._v("single RX-queue id")]),t._v(" （出于性能考量）。因此，用户空间的程序只会收到某个特定的 RX-queue id  下的 frames。然而事实上网卡会通过 RSS-Hashing，把流量散列到不同的 RX-queues 之间。因此，流量可能没有到达你所期望的那个队列。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("RSS (Receive Side Scaling) Hashing 是一种能够在多处理器系统下使接收报文在多个CPU之间高效分发的网卡驱动技术。网卡对接收到的报文进行解析，获取IP地址、协议和端口五元组信息。网卡通过配置的 HASH 函数根据五元组信息计算出 HASH 值,也可以根据二、三或四元组进行计算。取HASH值的低几位（这个具体网卡可能不同）作为 RETA (redirection table) 的索引，根据 RETA 中存储的值分发到对应的 CPU。")])]),t._v(" "),a("p",[t._v("为了解决这个问题，你必须配置网卡，让流进入一个特定的 RX-queue，可以通过 ethtool 或 TC HW offloading filter 设置。下面的例子展示了如何配置网卡，将所有的 UDP ipv4 流量都导入 "),a("em",[t._v("RX-queue id")]),t._v(" 42：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ethtool -N <interface> flow-type udp4 action 42\n")])])]),a("p",[t._v("参数 "),a("em",[t._v("action")]),t._v(" 指定了目标 "),a("em",[t._v("RX-queue")]),t._v("。一般来说，上面的这个流量转发的规则包含了匹配准则和 action。L2、L3 和 L4 header 值能被用来指定匹配准则。如果想要阅读更详细的文档，请查看 ethtool 的 man page （"),a("code",[t._v("man ethtool")]),t._v("）。它记载了 header 中所有能够用来作为匹配准则的值。")]),t._v(" "),a("p",[t._v("其他替代的方案：")]),t._v(" "),a("ol",[a("li",[t._v("创建和 RX-queue 数量相同的  AF_XDP sockets，然后由用户空间使用 "),a("code",[t._v("poll/select")]),t._v(" 等方法轮询这些 sockets。")]),t._v(" "),a("li",[t._v("出于测试目的，也可以把 RX-queue 的数量削减到 1，例如：使用命令 "),a("code",[t._v("ethtool -L <interface> combined 1")]),t._v("。")])]),t._v(" "),a("p",[t._v("但是在用 "),a("code",[t._v("testenv/testenv.sh")]),t._v(" 脚本虚拟出来的网卡用不了 "),a("code",[t._v("ethtool")]),t._v(" 的上面这些和 RX-queue 相关的命令。")])])]),t._v(" "),a("h3",{attrs:{id:"zero-copy-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zero-copy-模式"}},[t._v("#")]),t._v(" zero-copy 模式")]),t._v(" "),a("p",[t._v("正如前面提过的 AF_XDP 依赖于驱动的 "),a("code",[t._v("XDP_REDIRECT")]),t._v(" action 实现。对于所有实现了 "),a("code",[t._v("XDP_REDIRECT")]),t._v(" action 的驱动，就都支持 “copy-mode” 下的 AF_XDP。“copy-mode” 非常快，只拷贝一次 frame（包括所有 XDP 相关的 meta-data）到 UMEM 区域。用户空间的 API 也是如此。")]),t._v(" "),a("p",[t._v("为了支持 AF_XDP 的 “zero-copy” 模式，驱动需要在 NIC RX-ring 结构中直接实现并暴露出注册和使用 UMEM 区域的 API，以便使用 DMA。针对你的应用场景，在支持 “zero-copy”  的驱动上使用 “copy-mode” 仍然可能是有意义的。如果出于某些原因，并不是 RX-queue 中所有的流量都是要发给 AF_XDP socket 的，XDP 程序在 "),a("code",[t._v("XDP_REDIRECT")]),t._v(" 和 "),a("code",[t._v("XDP_PASS")]),t._v(" 间交替，如上面的 Advance03 示例中的那样，那么 “copy-mode” 可能是更好的选择。因为在 “zero-copy” 模式下使用 XDP_PASS 的代价很高，涉及到了为 frame 分配内存和执行内存拷贝。")]),t._v(" "),a("h3",{attrs:{id:"在-stm32mp157a-开发板上跑这个-demo-碰到的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在-stm32mp157a-开发板上跑这个-demo-碰到的问题"}},[t._v("#")]),t._v(" 在 STM32MP157A 开发板上跑这个 demo 碰到的问题")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("板载系统没有开启 AF_XDP_SOCKET 支持（幸亏厂商提供了基于 5.4.31 内核的 Ubuntu 18.04，而且提供了他们构建开发板时的项目源码，只需要改下配置项，重新编译下内核，但凡他们搞个低版本的，闹不好我就寄了）。那么需要在内核源码目录下的"),a("code",[t._v(".config")]),t._v(" 中重新编译一份 arm 架构的内核，将生成的 uImage 镜像和设备树文件拷贝到板子的 "),a("code",[t._v("/boot")]),t._v(" 目录下。板子我是用的 sd 卡安装的 ubuntu，boot 目录没有自动挂载到，还要到 "),a("code",[t._v("/dev")]),t._v(" 下找到它所在的分区（记录一下，我自己的板子是 block1p4），对应的 u-boot 的配置文件中如果启动的路径不对，可能也要修改。这里就庆幸自己是拿的 sd 卡装的，不然在只能进入到 u-boot 终端的情况下，只用 tftp 还处理不了 "),a("code",[t._v("boot")]),t._v(" 目录下错误的路径配置。")])]),t._v(" "),a("li",[a("p",[t._v("编译上面的例子时候，板子缺少 "),a("code",[t._v("libelf-dev")]),t._v(" 包，会报错丢失 "),a("code",[t._v("<gelf.h>")]),t._v(" 头文件。")])]),t._v(" "),a("li",[a("p",[t._v("编译上面的例子时候，板子的"),a("code",[t._v("/usr/include/")]),t._v(" 下没有 "),a("code",[t._v("asm")]),t._v(" 文件夹，只有 "),a("code",[t._v("asm_generic")]),t._v("。有人博客里写，给 "),a("code",[t._v("asm_generic")]),t._v(" 链接到 "),a("code",[t._v("asm")]),t._v(" 就行了。亲测不是如此，二者包含的头文件并不相同。")]),t._v(" "),a("p",[t._v("后来发现该目录下，还有一个 "),a("code",[t._v("arm")]),t._v("开头的文件夹，推测里面应该包含了板子 "),a("code",[t._v("arm")]),t._v(" 架构下的相关头文件。打开后果然如此，有一个"),a("code",[t._v("asm")]),t._v("，那么只需要在"),a("code",[t._v("/usr/include")]),t._v(" 下做一个软连接 "),a("code",[t._v("ln -s")]),t._v(" 到它，命名成 "),a("code",[t._v("asm")]),t._v(" 就行了。")])])]),t._v(" "),a("h2",{attrs:{id:"其他可以参考的资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他可以参考的资料"}},[t._v("#")]),t._v(" 其他可以参考的资料")]),t._v(" "),a("p",[t._v("Linux manual page 上的 "),a("a",{attrs:{href:"https://man7.org/linux/man-pages/man7/bpf-helpers.7.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("bpf-helpers"),a("OutboundLink")],1),t._v(" 页面。")]),t._v(" "),a("p",[t._v("前几篇 bpf 的相关笔记。")]),t._v(" "),a("p",[t._v("组会和同学分享了近期的学习积累，做了一个 ppt，包含一些相关论文的概述，"),a("a",{attrs:{href:"./eBPF.pptx"}},[t._v("slides 链接")]),t._v("。")]),t._v(" "),a("Comment",{attrs:{lang:"zh-CN"}})],1)}),[],!1,null,null,null);s.default=n.exports}}]);