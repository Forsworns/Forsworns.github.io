import{_ as e,c as a,o as s,e as l}from"./app.68e2223d.js";const u=JSON.parse('{"title":"Yet Another JSON Lib","description":"阅读了知乎上的教程用Modern C++重写~","frontmatter":{"title":"Yet Another JSON Lib","description":"阅读了知乎上的教程用Modern C++重写~","tags":["C++"]},"headers":[{"level":3,"title":"命名空间、作用域","slug":"命名空间、作用域","link":"#命名空间、作用域","children":[]},{"level":3,"title":"强枚举类型","slug":"强枚举类型","link":"#强枚举类型","children":[]},{"level":3,"title":"使用了的智能指针","slug":"使用了的智能指针","link":"#使用了的智能指针","children":[]},{"level":3,"title":"去掉了手写的数据结构","slug":"去掉了手写的数据结构","link":"#去掉了手写的数据结构","children":[]},{"level":3,"title":"未做OOP实现 建议参考","slug":"未做oop实现-建议参考","link":"#未做oop实现-建议参考","children":[]}],"relativePath":"zh/blogs/20200816/index.md"}'),o={name:"zh/blogs/20200816/index.md"},n=l(`<h1 id="yet-another-json-lib" tabindex="-1">Yet Another JSON Lib <a class="header-anchor" href="#yet-another-json-lib" aria-hidden="true">#</a></h1><nav class="table-of-contents"><ul><li><a href="#命名空间、作用域">命名空间、作用域</a></li><li><a href="#强枚举类型">强枚举类型</a></li><li><a href="#使用了的智能指针">使用了的智能指针</a></li><li><a href="#去掉了手写的数据结构">去掉了手写的数据结构</a></li><li><a href="#未做oop实现-建议参考">未做OOP实现 建议参考</a></li></ul></nav><p>一直找不到一个简单的Modern C++项目练手，在github上找了很久都太复杂了。最近在知乎上读到了一个写JSON库解析的<a href="https://zhuanlan.zhihu.com/json-tutorial" target="_blank" rel="noreferrer">系列教程</a>（后续简写为教程），作者是写给C初学者的。</p><p>想了想我太菜了，果然还是这种事无巨细的教程适合我QAQ，于是就动手了：<a href="https://github.com/Forsworns/yJson" target="_blank" rel="noreferrer">项目地址</a>。</p><p>既然主要目的是练习新标准，所以难免有拿着锤子看到哪都是钉子的感觉。可惜这个项目里没有多少用到模板的地方，好多deep♂dark♂magic都还没有试过。设计上和教程相同，也没有过多使用OOP。</p><p>那么在原教程的基础上的主要改动如下：</p><h3 id="命名空间、作用域" tabindex="-1">命名空间、作用域 <a class="header-anchor" href="#命名空间、作用域" aria-hidden="true">#</a></h3><p>很自然的使用了命名空间防止冲突，干掉了原来的前缀。</p><p><code>using</code>的新语义用来替代<code>typedef</code>也很舒服。</p><p>c++17可以在<code>if/switch</code>中定义并初始化变量，在<code>parseArray</code>和<code>parseObject</code>中。</p><h3 id="强枚举类型" tabindex="-1">强枚举类型 <a class="header-anchor" href="#强枚举类型" aria-hidden="true">#</a></h3><p>主要就是把原来的枚举都改成了强枚举类型。教程中用到的</p><p>不过现在用起来可能会更冗杂……毕竟需要加类名。</p><h3 id="使用了的智能指针" tabindex="-1">使用了的智能指针 <a class="header-anchor" href="#使用了的智能指针" aria-hidden="true">#</a></h3><p>C++内存、锁、套接字等资源管理的思路是RAII（Resource Acquisition Is Initialization），资源在初始化时获取、在离开作用域后销毁。感谢智能指针，干掉了教程里的<code>free</code>，在教育意义上似乎是种退步😆。但是好处是不用担心内存泄漏问题了。</p><p>在<code>parseObject</code>函数中，没有直接创建指向<code>Entry el</code>的<code>val</code>的指针，而是选择和解析<code>el-&gt;key</code>一样，使用临时变量<code>elKey</code>和<code>elVal</code>传递。有两种常见的错误方式：如果是用<code>auto elVal = make_shared&lt;Value&gt;(el-&gt;val)</code>会将<code>el-&gt;val</code>复制一份，调用<code>parseValue(s, elVal)</code>不会修改<code>el-&gt;Val</code>；如果是用<code>shared_ptr&lt;Value&gt; elVal(&amp;el-&gt;val) </code>，则会导致<code>shared_ptr</code>在执行析构的时候，重复析构<code>el-&gt;val</code>。</p><h3 id="去掉了手写的数据结构" tabindex="-1">去掉了手写的数据结构 <a class="header-anchor" href="#去掉了手写的数据结构" aria-hidden="true">#</a></h3><p>干掉了手写的复杂数据结构，改用了标准库，比起教程似乎也是一种退步😆。比较值得一提的是，在解析对象的时候，本来设想的是使用<code>unordered_map</code>。但是由于数据结构间互相引用，需要前向声明一个不完整的类。这个时候就出现了一个坑，C++标准库中的容器不支持使用不完整类型，似乎boost做了支持（未考证），而标准库则直到C++17才允许部分容器使用不完整类型。也就是说，目前只有<code>vector</code>,<code>list</code>和<code>forward_list</code>支持使用不完整类型，如下</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // forward declaration</span></span>
<span class="line"><span style="color:#F78C6C;">using</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">myVec</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">vector</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">&gt;;</span><span style="color:#676E95;font-style:italic;"> // right</span></span>
<span class="line"><span style="color:#A6ACCD;">vector</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">A</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> a</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> // right</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// using myMap = map&lt;int,A&gt;; wrong</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// map&lt;int,A&gt; b; // wrong</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">{};</span></span>
<span class="line"></span></code></pre></div><h3 id="未做oop实现-建议参考" tabindex="-1">未做OOP实现 建议<a href="https://github.com/zsmj2017/MiniJson" target="_blank" rel="noreferrer">参考</a> <a class="header-anchor" href="#未做oop实现-建议参考" aria-hidden="true">#</a></h3>`,20),t=[n];function r(c,p,i,d,h,y){return s(),a("div",null,t)}const f=e(o,[["render",r]]);export{u as __pageData,f as default};
