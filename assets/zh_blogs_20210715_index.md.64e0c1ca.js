import{_ as s,c as a,o as n,e as o}from"./app.db17c96a.js";const A=JSON.parse('{"title":"XDP Tutorial 学习笔记（附 tutorial slides）","description":"学习一下 libbpf 下 XDP 的使用","frontmatter":{"title":"XDP Tutorial 学习笔记（附 tutorial slides）","description":"学习一下 libbpf 下 XDP 的使用","tags":["bpf","xdp"]},"headers":[{"level":2,"title":"教程的简介","slug":"教程的简介","link":"#教程的简介","children":[]},{"level":2,"title":"Advance03 示例的笔记","slug":"advance03-示例的笔记","link":"#advance03-示例的笔记","children":[{"level":3,"title":"AF_XDP 的性能提升从何而来？","slug":"af-xdp-的性能提升从何而来","link":"#af-xdp-的性能提升从何而来","children":[]},{"level":3,"title":"示例代码阅读","slug":"示例代码阅读","link":"#示例代码阅读","children":[]},{"level":3,"title":"可能碰到的问题","slug":"可能碰到的问题","link":"#可能碰到的问题","children":[]},{"level":3,"title":"zero-copy 模式","slug":"zero-copy-模式","link":"#zero-copy-模式","children":[]},{"level":3,"title":"在 STM32MP157A 开发板上跑这个 demo 碰到的问题","slug":"在-stm32mp157a-开发板上跑这个-demo-碰到的问题","link":"#在-stm32mp157a-开发板上跑这个-demo-碰到的问题","children":[]}]},{"level":2,"title":"其他可以参考的资料","slug":"其他可以参考的资料","link":"#其他可以参考的资料","children":[]}],"relativePath":"zh/blogs/20210715/index.md"}'),e={name:"zh/blogs/20210715/index.md"},l=o(`<nav class="table-of-contents"><ul><li><a href="#教程的简介">教程的简介</a></li><li><a href="#advance03-示例的笔记">Advance03 示例的笔记</a><ul><li><a href="#af-xdp-的性能提升从何而来">AF_XDP 的性能提升从何而来？</a></li><li><a href="#示例代码阅读">示例代码阅读</a></li><li><a href="#可能碰到的问题">可能碰到的问题</a></li><li><a href="#zero-copy-模式">zero-copy 模式</a></li><li><a href="#在-stm32mp157a-开发板上跑这个-demo-碰到的问题">在 STM32MP157A 开发板上跑这个 demo 碰到的问题</a></li></ul></li><li><a href="#其他可以参考的资料">其他可以参考的资料</a></li></ul></nav><h1 id="xdp-tutorial-学习笔记" tabindex="-1">XDP Tutorial 学习笔记 <a class="header-anchor" href="#xdp-tutorial-学习笔记" aria-hidden="true">#</a></h1><p>xdp 的相关论文发在 2018 年 CONEXT 上，文章名称是 &quot;The eXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel&quot;，是 OA 的，可以直接<a href="https://dl.acm.org/doi/10.1145/3281411.3281443" target="_blank" rel="noreferrer">下载来看</a>。</p><p>学习一下 xdp 官方提供的教程，项目地址额为 <a href="https://github.com/xdp-project/xdp-tutorial" target="_blank" rel="noreferrer">xdp-project/xdp-tutorial: XDP tutorial</a>。该教程依赖的 libbpf 是19年的一版，直接用新版会有问题，需要下项目里的子模块指定的 <a href="https://github.com/libbpf/libbpf/tree/b91f53ec5f1aba2a9d01dc00c4434063abd921e8" target="_blank" rel="noreferrer">libbpf/libbpf at b91f53ec5f1aba2a9d01dc00c4434063abd921e8</a>。</p><h2 id="教程的简介" tabindex="-1">教程的简介 <a class="header-anchor" href="#教程的简介" aria-hidden="true">#</a></h2><p>比较基础的章节是 <code>basic01</code> 到 <code>basic04</code> 目录下的内容。</p><ul><li><code>basic02</code>：讲解了 libbpf 怎么加载 bpf 代码的。让读者自己实现一个简化的加载过程。用户实现的函数，使用 <code>_</code> 前缀与教程中 xdp 团队提供的 api 相区分。相应的 api 是没有 <code>_</code> 前缀的，位于 <code>common</code> 目录下。例如，<code>common/common_user_bpf_xdp.c</code> 下的<code>load_bpf_and_xdp_attach()</code> 函数。</li><li><code>basic03</code>：讲解了 bpf map 的使用。</li><li><code>basic04</code>：讲解了跨应用共享 bpf map，使用的是 pinning maps 技术。</li></ul><p><code>tracing01</code> 到 <code>tracing04</code> 是做 tracing 方面的应用。</p><p><code>packet01</code> 到 <code>packet03</code> 是从包的层面上做了 parsing、rewriting、redirecting。</p><p><code>advance01</code> 是 xdp 和 tc 交互的例子。</p><p><code>advance03</code> 很有趣，是一个比较完整的例子，展示了如何通过 xdp 在用户空间解析 IPV6 ICMP 报文，并发送回复。是用了一种新型的 socket 地址类型，<code>AF_XDP</code>，可以在 kernel 的文档中找到<a href="https://www.kernel.org/doc/html/latest/networking/af_xdp.html" target="_blank" rel="noreferrer"> AF_XDP 的介绍</a>。</p><p>这些教程中的 Assignment 的答案分布：<code>advance</code> 和 <code>tracing</code> 部分的答案就是在代码里的。<code>basic</code> 和 <code>packet</code> 部分的是在 <code>basic-solutions</code> 和<code>packet-solutions</code> 目录下。</p><h2 id="advance03-示例的笔记" tabindex="-1">Advance03 示例的笔记 <a class="header-anchor" href="#advance03-示例的笔记" aria-hidden="true">#</a></h2><p>xdp 没有完全绕过内核，但是可以让包跳过内核的网络栈，直接从用户空间读取，可以通过 <code>AF_XDP</code> 的 <code>XDP_REDIRECT</code> 语义实现。</p><p>首先简要记录一下 <code>AF_XDP</code> 套接字。<code>AF_XDP</code> socket， 缩写为 XSK，可以通过系统调用 <code>socket()</code> 创建。每个 XSK 都有两个环来存储数据，一个 RX ring 和一个 TX ring。套接字能够用 RX ring 接收包，通过 TX ring 发送包。这些环是通过 <code>setsockopts</code> 中的选项 <code>XDP_RX_RING</code> 和 <code>XDP_TX_RING</code> 设置的。每个套接字至少需要其中的一个（以作为单侧的 source/sink node）。RX/TX ring 指向内存中一块叫做 UMEM 的数据。RX 和 TX 能够共享同一块 UMEM 区域，以防在 RX 和 TX 之间频繁地进行数据拷贝。另外，如果由于潜在的重传，一个包需要被保存一段时间，这些指针也能暂时指向别的包，避免拷贝数据。</p><p>在 BPF 侧的 AF_XDP 程序，参数是 <code>struct xdp_md</code>，包含原始 frame 的数据。可以返回一些状态来表示对该 frame 的处理意见，比如：</p><ul><li><code>XDP_PASS</code>：继续传递到 Linux 后续的协议栈中处理。</li><li><code>XDP_REDIRECT</code>：将包通过 UMEM 传递到用户空间处理。</li><li><code>XDP_DROP</code>：直接丢弃这个包。</li><li><code>XDP_TX</code> 可以直接发回给网卡，可以用来在内核中做快速的回复。比如下面 Advance03 中做的事情，去交换 ICMP 报文的发送方和接收方。该例子其实可以在内核中完成，然后用 <code>XDP_TX</code> 发回去，不是必须 redirect 到用户空间再做。</li></ul><h3 id="af-xdp-的性能提升从何而来" tabindex="-1">AF_XDP 的性能提升从何而来？ <a class="header-anchor" href="#af-xdp-的性能提升从何而来" aria-hidden="true">#</a></h3><p>AF_XDP socket 非常快，在这个性能提升的背后隐藏了多少秘密呢？ AF_XDP 的 idea 背后的基础可以追溯到 <a href="https://en.wikipedia.org/wiki/Van_Jacobson" target="_blank" rel="noreferrer">Van Jacobson</a> 的关于 <a href="https://lwn.net/Articles/169961/" target="_blank" rel="noreferrer">network channels</a> 的报告中。在该报告中，描述了如何直接从驱动的 RX-queue （接收队列）去创建一个无锁的 <a href="https://lwn.net/Articles/169961/" target="_blank" rel="noreferrer">channel</a> 构建 AF_XDP socket。</p><p>（前面介绍 <code>AF_XDP</code> 的内容也提到了），AF_XDP 使用的队列是 Single-Producer/Single-Consumer (SPSC) 的描述符（descriptor）环形队列：</p><ul><li><p><strong>Single-Producer</strong> (SP) 绑定到了某个特定的 RX <strong>queue id</strong> 上，通过 NAPI-softirq 确保在软中断（softirq）触发期间，只有一个 CPU 来处理一个 RX-queue id。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>NAPI 是 Linux 上采用的一种提高网络处理效率的技术，它的核心概念就是不采用中断的方式读取数据，否则包太多了，不停触发中断。而代之以首先采用中断唤醒数据接收的服务程序，然后 POLL 的方法来轮询数据。</p></div></li><li><p><strong>Single-Consumer</strong> (SC) 则是一个应用，从环中读取指向 UMEM 区域的描述符（descriptor）。</p></li></ul><p>因此不需要对每个包都分配一次内存。可以在事先为 UMEM 内存区域进行分配（因此 UMEM 是有界的）。UMEM 包含了一些大小相同的块，环中的指针会引用它们的地址来引用这些块。这个地址就是在整个 UMEM 区域中的偏移量。用户空间负责为 UMEM 分配内存，分配的方法很灵活，可以用 malloc、mmap、huge pages 等形式。这个内存空间通过在 <code>setsockopt()</code> 方法中设置 <code>XDP_UMEM_REG</code> 触发相应的系统调用，注册到内核中。<strong>需要注意的是</strong>：这样就意味着你需要负责及时地将 frame 返回给 UMEM，并且需要为你的应用提前分配足够的内存。</p><p>Van Jacobson 在报告中谈到的 <a href="http://www.lemis.com/grog/Documentation/vj/lca06vj.pdf" target="_blank" rel="noreferrer">transport signature</a>，在 XDP/eBPF 程序中体现为选择将 frame <code>XDP_REDIRECT</code> 到哪个 AF_XDP socket。</p><h3 id="示例代码阅读" tabindex="-1">示例代码阅读 <a class="header-anchor" href="#示例代码阅读" aria-hidden="true">#</a></h3><p>打开 <code>advanced03-AF_XDP/af_xdp_kern.c</code>，它很精简，只有四十行代码。首先定义了两个 bpf map，一个存储 XSK，一个存储包的数量数据。然后定义了一个 bpf 程序，它的参数是 <code>struct xdp_md</code>，所以它是一个 <strong>BPF_PROG_TYPE_XDP</strong> 类型的 BPF 程序。这段程序通过 <code>SEC()</code> 宏放在了<code>xdp_sock</code> 段中，用 bpf helper 函数来和定义好的 bpf map 交互。注意其中的代码</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/* We pass every other packet */</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((*</span><span style="color:#A6ACCD;">pkt_count</span><span style="color:#89DDFF;">)++</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> XDP_PASS</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>是间隔一个地直接返回 <code>XDP_PASS</code>，下一个包才会用 <code>bpf_redirect_map</code> 去转发。也就是说，过滤掉了一半的包。</p><p>在用户空间代码 <code>advanced03-AF_XDP/af_xdp_user.c</code> 中。首先是做了 bpf 用户空间程序必要的一些工作，比如 <code>setrlimit(RLIMIT_MEMLOCK, &amp;rlim)</code> 去释放内存限制。这也是为什么必须用 sudo 权限运行 bpf 程序。</p><p>用 <code>stats_record</code> 结构体记录收发数量，在代码最后会单独开一个线程去调用 <code>stats_poll()</code> 函数打印实时的收发数据，用信号 <code>signal(SIGINT, exit_application)</code> 注册 <code>exit_application()</code> 函数，在结束时设置变量，帮助 <code>stats_poll()</code> 停止监测。</p><p><code>xsk_socket_info</code> 结构体包装 <code>xsk_socket</code>，<code>xsk_umem_info</code> 结构体包装 <code>xsk_umem</code>。这部分代码会反复用到缩写 PROD 代表 producer，也就是发送端 tx；缩写 CONS 代表 consumer，也就是接收端 rx。因为 XSK 默认是 Single-Producer-Single-Consumer 的。</p><p><code>xsk_configure_socket()</code> 初始化了 XSK，注意这里初始化发送端和接收端时，是传设置项 <code>xsk_cfg</code> 给库函数 <code>xsk_socket__create()</code>。<code>xsk_cfg.rx_size</code> 和 <code>xsk_cfg.tx_size</code> 分别初始化成了 <code>XSK_RING_CONS__DEFAULT_NUM_DESCS</code> 和 <code>XSK_RING_PROD__DEFAULT_NUM_DESCS</code>，他们会在库函数 <code>xsk_socket__create()</code> 中传递给系统调用 <code>setsockopt()</code> 去完成 XSK 中的 tx 和 rx 的创建。他们是定义在 <code>xsk.h</code> 中的宏，值都是 2048。事实上，只能被初始化成2的幂次。因为在库里的 <code>xsk.h</code> 中，获取 <code>xdp_desc</code> 的函数是这么定义的</p><div class="language-C"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">inline</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> xdp_desc </span><span style="color:#89DDFF;">*</span><span style="color:#82AAFF;">xsk_ring_prod__tx_desc</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> xsk_ring_prod </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;font-style:italic;">tx</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">						      __u32 </span><span style="color:#A6ACCD;font-style:italic;">idx</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> xdp_desc </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">descs </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> xdp_desc </span><span style="color:#89DDFF;">*)</span><span style="color:#A6ACCD;">tx</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">ring</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">descs</span><span style="color:#89DDFF;">[</span><span style="color:#F07178;">idx </span><span style="color:#89DDFF;">&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">tx</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">mask</span><span style="color:#89DDFF;">];</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">inline</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> xdp_desc </span><span style="color:#89DDFF;">*</span></span>
<span class="line"><span style="color:#82AAFF;">xsk_ring_cons__rx_desc</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> xsk_ring_cons </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;font-style:italic;">rx</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> __u32 </span><span style="color:#A6ACCD;font-style:italic;">idx</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> xdp_desc </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">descs </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> xdp_desc </span><span style="color:#89DDFF;">*)</span><span style="color:#A6ACCD;">rx</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">ring</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">descs</span><span style="color:#89DDFF;">[</span><span style="color:#F07178;">idx </span><span style="color:#89DDFF;">&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">rx</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">mask</span><span style="color:#89DDFF;">];</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/* Rx/Tx descriptor */</span></span>
<span class="line"><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> xdp_desc </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	__u64 addr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	__u32 len</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	__u32 options</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>注意 <code>idx &amp; tx-&gt;mask</code> 和 <code>idx &amp; rx-&gt;mask</code> 是在用按位与运算去防止下标溢出，相当于在取模。这里的 <code>mask</code> 是在库里的 <code>xsk.c</code> 中的<code>xsk_socket__create()</code> 函数中初始化的，都是初始化成 <code>size-1</code> 的，也就是 2047，各位都是 1，如果 <code>size</code> 不是 2 的幂次，显然就不能这么干了。</p><p>创建好 XSK，就可以监听了，这部分逻辑写在 <code>rx_and_process()</code> 中，用 <code>poll(struct pollfd *__fds, nfds_t __nfds, -1)</code> 系统调用去监听之前创建好的 XSK，在没有触发事件时阻塞。收到包后，调用 <code>handle_receive_packets()</code> 在 XSK 对应的 umem 中读取 rx 端，也就是 consumer 接收到的包。经过最深层的 <code>process_packet()</code> 处理，做的就是把包的指针转换成各层的首部，然后读取他们。因为实验中只有 IPV6 ICMP 报文，所以就直接像下面这样写了。处理完后，写入到 umem 中 tx 也就是 producer 管理的内存中。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">process_packet</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> xsk_socket_info </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;font-style:italic;">xsk</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">uint64_t</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">addr</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">uint32_t</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">len</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#C792EA;">uint8_t</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">pkt </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">xsk_umem__get_data</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">xsk</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">umem</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> addr</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// get header one by one</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> ethhdr </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">eth </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> ethhdr </span><span style="color:#89DDFF;">*)</span><span style="color:#F07178;"> pkt</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// pointer adds 1*sizeof(ethhdr) in fact</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> ipv6hdr </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">ipv6 </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> ipv6hdr </span><span style="color:#89DDFF;">*)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">eth </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// pointer adds 1*sizeof(ipv6hdr) in fact</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> icmp6hdr </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">icmp </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> icmp6hdr </span><span style="color:#89DDFF;">*)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">ipv6 </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">		</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// exchange source and destination</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">memcpy</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">tmp_mac</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">eth</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">h_dest</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> ETH_ALEN</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">memcpy</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">eth</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">h_dest</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">eth</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">h_source</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> ETH_ALEN</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">memcpy</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">eth</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">h_source</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> tmp_mac</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> ETH_ALEN</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#A6ACCD;">icmp</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">icmp6_type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> ICMPV6_ECHO_REPLY</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// replace icmp checksum in the packet</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">csum_replace2</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">icmp</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">icmp6_cksum</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#82AAFF;">htons</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">ICMPV6_ECHO_REQUEST </span><span style="color:#89DDFF;">&lt;&lt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">8</span><span style="color:#89DDFF;">),</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#82AAFF;">htons</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">ICMPV6_ECHO_REPLY </span><span style="color:#89DDFF;">&lt;&lt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">8</span><span style="color:#89DDFF;">));</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// check remaining space in the ring </span></span>
<span class="line"><span style="color:#F07178;">	ret </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">xsk_ring_prod__reserve</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">xsk</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">tx</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#F07178;">tx_idx</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">ret </span><span style="color:#89DDFF;">!=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">		/* No more transmit slots, drop the packet */</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// write to tx</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">xsk_ring_prod__tx_desc</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">xsk</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">tx</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> tx_idx</span><span style="color:#89DDFF;">)-&gt;</span><span style="color:#A6ACCD;">addr</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> addr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">xsk_ring_prod__tx_desc</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">xsk</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">tx</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> tx_idx</span><span style="color:#89DDFF;">)-&gt;</span><span style="color:#A6ACCD;">len</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> len</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">xsk_ring_prod__submit</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">xsk</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">tx</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>至此该节内容结束。</p><h3 id="可能碰到的问题" tabindex="-1">可能碰到的问题 <a class="header-anchor" href="#可能碰到的问题" aria-hidden="true">#</a></h3><ul><li><p>首先这些 BPF 相关的 demo 都是需要 <code>sudo</code> 去跑的，需要管理员权限。</p></li><li><p>系统内核太旧了，本身不支持 <code>AF_XDP</code> socket。</p></li><li><p>最常见的错误：为什么我在 AF_XDP socket 上看不到任何流量？</p><p>正如你在上面了解到的，AF_XDP socket 绑定到了一个 <strong>single RX-queue id</strong> （出于性能考量）。因此，用户空间的程序只会收到某个特定的 RX-queue id 下的 frames。然而事实上网卡会通过 RSS-Hashing，把流量散列到不同的 RX-queues 之间。因此，流量可能没有到达你所期望的那个队列。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>RSS (Receive Side Scaling) Hashing 是一种能够在多处理器系统下使接收报文在多个CPU之间高效分发的网卡驱动技术。网卡对接收到的报文进行解析，获取IP地址、协议和端口五元组信息。网卡通过配置的 HASH 函数根据五元组信息计算出 HASH 值,也可以根据二、三或四元组进行计算。取HASH值的低几位（这个具体网卡可能不同）作为 RETA (redirection table) 的索引，根据 RETA 中存储的值分发到对应的 CPU。</p></div><p>为了解决这个问题，你必须配置网卡，让流进入一个特定的 RX-queue，可以通过 ethtool 或 TC HW offloading filter 设置。下面的例子展示了如何配置网卡，将所有的 UDP ipv4 流量都导入 <em>RX-queue id</em> 42：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">ethtool -N &lt;interface&gt; flow-type udp4 action 42</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>参数 <em>action</em> 指定了目标 <em>RX-queue</em>。一般来说，上面的这个流量转发的规则包含了匹配准则和 action。L2、L3 和 L4 header 值能被用来指定匹配准则。如果想要阅读更详细的文档，请查看 ethtool 的 man page （<code>man ethtool</code>）。它记载了 header 中所有能够用来作为匹配准则的值。</p><p>其他替代的方案：</p><ol><li>创建和 RX-queue 数量相同的 AF_XDP sockets，然后由用户空间使用 <code>poll/select</code> 等方法轮询这些 sockets。</li><li>出于测试目的，也可以把 RX-queue 的数量削减到 1，例如：使用命令 <code>ethtool -L &lt;interface&gt; combined 1</code>。</li></ol><p>但是在用 <code>testenv/testenv.sh</code> 脚本虚拟出来的网卡用不了 <code>ethtool</code> 的上面这些和 RX-queue 相关的命令。</p></li></ul><h3 id="zero-copy-模式" tabindex="-1">zero-copy 模式 <a class="header-anchor" href="#zero-copy-模式" aria-hidden="true">#</a></h3><p>正如前面提过的 AF_XDP 依赖于驱动的 <code>XDP_REDIRECT</code> action 实现。对于所有实现了 <code>XDP_REDIRECT</code> action 的驱动，就都支持 “copy-mode” 下的 AF_XDP。“copy-mode” 非常快，只拷贝一次 frame（包括所有 XDP 相关的 meta-data）到 UMEM 区域。用户空间的 API 也是如此。</p><p>为了支持 AF_XDP 的 “zero-copy” 模式，驱动需要在 NIC RX-ring 结构中直接实现并暴露出注册和使用 UMEM 区域的 API，以便使用 DMA。针对你的应用场景，在支持 “zero-copy” 的驱动上使用 “copy-mode” 仍然可能是有意义的。如果出于某些原因，并不是 RX-queue 中所有的流量都是要发给 AF_XDP socket 的，XDP 程序在 <code>XDP_REDIRECT</code> 和 <code>XDP_PASS</code> 间交替，如上面的 Advance03 示例中的那样，那么 “copy-mode” 可能是更好的选择。因为在 “zero-copy” 模式下使用 XDP_PASS 的代价很高，涉及到了为 frame 分配内存和执行内存拷贝。</p><h3 id="在-stm32mp157a-开发板上跑这个-demo-碰到的问题" tabindex="-1">在 STM32MP157A 开发板上跑这个 demo 碰到的问题 <a class="header-anchor" href="#在-stm32mp157a-开发板上跑这个-demo-碰到的问题" aria-hidden="true">#</a></h3><ol><li><p>板载系统没有开启 AF_XDP_SOCKET 支持（幸亏厂商提供了基于 5.4.31 内核的 Ubuntu 18.04，而且提供了他们构建开发板时的项目源码，只需要改下配置项，重新编译下内核，但凡他们搞个低版本的，闹不好我就寄了）。那么需要在内核源码目录下的<code>.config</code> 中重新编译一份 arm 架构的内核，将生成的 uImage 镜像和设备树文件拷贝到板子的 <code>/boot</code> 目录下。板子我是用的 sd 卡安装的 ubuntu，boot 目录没有自动挂载到，还要到 <code>/dev</code> 下找到它所在的分区（记录一下，我自己的板子是 block1p4），对应的 u-boot 的配置文件中如果启动的路径不对，可能也要修改。这里就庆幸自己是拿的 sd 卡装的，不然在只能进入到 u-boot 终端的情况下，只用 tftp 还处理不了 <code>boot</code> 目录下错误的路径配置。</p></li><li><p>编译上面的例子时候，板子缺少 <code>libelf-dev</code> 包，会报错丢失 <code>&lt;gelf.h&gt;</code> 头文件。</p></li><li><p>编译上面的例子时候，板子的<code>/usr/include/</code> 下没有 <code>asm</code> 文件夹，只有 <code>asm_generic</code>。有人博客里写，给 <code>asm_generic</code> 链接到 <code>asm</code> 就行了。亲测不是如此，二者包含的头文件并不相同。</p><p>后来发现该目录下，还有一个 <code>arm </code>开头的文件夹，推测里面应该包含了板子 <code>arm</code> 架构下的相关头文件。打开后果然如此，有一个<code>asm</code>，那么只需要在<code>/usr/include</code> 下做一个软连接 <code>ln -s</code> 到它，命名成 <code>asm</code> 就行了。</p></li></ol><h2 id="其他可以参考的资料" tabindex="-1">其他可以参考的资料 <a class="header-anchor" href="#其他可以参考的资料" aria-hidden="true">#</a></h2><p>Linux manual page 上的 <a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html" target="_blank" rel="noreferrer">bpf-helpers</a> 页面。</p><p>前几篇 bpf 的相关笔记。</p><p>组会和同学分享了近期的学习积累，做了一个 ppt，包含一些相关论文的概述，<a href="./eBPF.pptx">slides 链接</a>。</p>`,47),p=[l];function c(t,r,d,i,F,D){return n(),a("div",null,p)}const _=s(e,[["render",c]]);export{A as __pageData,_ as default};
