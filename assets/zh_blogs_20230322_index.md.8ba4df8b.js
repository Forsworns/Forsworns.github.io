import{_ as e,c as n,o as a,e as i}from"./app.0f5a0ae1.js";const t="/assets/image-20230322221607084.83672566.png",s="/assets/image-20230322221748851.5545c363.png",r="/assets/image-20230322222444334.b0b4103e.png",c="/assets/image-20230322223211767.a9fa6ded.png",p="/assets/image-20230322223716783.3202bc3e.png",o="/assets/image-20230322225016280.e582b841.png",g="/assets/image-20230322230710828.f15a0c4d.png",b=JSON.parse('{"title":"GTC 2023 Scaling Deep Learning Training：Fast Inter-GPU Communication with NCCL","description":"NCCL 的源代码好难懂……","frontmatter":{"title":"GTC 2023 Scaling Deep Learning Training：Fast Inter-GPU Communication with NCCL","description":"NCCL 的源代码好难懂……","tags":["GPU"]},"headers":[],"relativePath":"zh/blogs/20230322/index.md"}'),m={name:"zh/blogs/20230322/index.md"},l=i('<nav class="table-of-contents"><ul></ul></nav><h1 id="gtc-2023-scaling-deep-learning-training-fast-inter-gpu-communication-with-nccl" tabindex="-1">GTC 2023 Scaling Deep Learning Training: Fast Inter-GPU Communication with NCCL <a class="header-anchor" href="#gtc-2023-scaling-deep-learning-training-fast-inter-gpu-communication-with-nccl" aria-hidden="true">#</a></h1><p><a href="https://www.nvidia.com/en-us/on-demand/session/gtcspring23-s51111/" target="_blank" rel="noreferrer">GTC 2023 大会上关于 NCCL 的演讲</a> 摘录，来自英伟达 Principal Engineer，Sylvain Jeaugey。</p><p>类似于 MPI 在并行计算中的地位，NCCL 是多卡集合通信的核心框架，NV 在 2016 年开始实现了这套框架，文档见<a href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/index.html" target="_blank" rel="noreferrer">NVIDIA Collective Communication Library (NCCL) Documentation</a>。</p><p>为什么需要 NCCL？这和模型的并行训练方法有关。最常见的并行训练方法是数据并行，在本地计算完梯度后，进行一次 NCCL 的 All Reduce 操作，让每张 GPU 上的都能同步到全局的梯度信息。缺陷是 GPU 数量增加后，batch size 需要增加，过大的 batch size 可能导致模型精度下降。</p><p><img src="'+t+'" alt="image-20230322221607084"></p><p>第二种是模型并行，把一个大模型的各个部分放置到不同的设备上，好处是可以避免数据并行中 batch size 的增大。但是坏处是这时需要用 NCCL 的 P2P Send/Recv 操作在各个部分进行参数的更新，不同部分的计算效率、参数量不同，可能存在空隙，利用率不足。</p><p><img src="'+s+'" alt="image-20230322221748851"></p><p>或者张量并行，将两个大型张量的计算拆分开，例如下图，使用一个 NCCL AllGather 操作收集各个部分的计算结果。</p><p><img src="'+r+'" alt="image-20230322222444334"></p><p>现在最火的莫过于大型语言模型（LLM），将上面三者结合，是一个并行训练的典型场景：</p><p><img src="'+c+'" alt="image-20230322223211767"></p><p>NCCL 有着丰富的特性，这里的重点是它单机内部的数据传输都是直接写成了核函数、自动拓扑分析（可以指定XML，意味着可以在虚拟机内部搞些骚操作）、Ring/Tree 结构下的集合通信实现、RDMA 支持。</p><p><img src="'+p+'" alt="image-20230322223716783"></p><p>接着 Sylvain 仔细讲了 Ring 和 Tree 结构，以 All Reduce 为例。Ring 很朴素，直接把所有节点穿成环，好处是简单易懂、负载均衡，坏处是线性增加的延迟，因为要把数据切分成 chunk 每个节点过一遍。Tree 则是很自然的二分思想，在树上进行 reduce 操作，延迟自然就低了。NCCL 中会建立两棵树，叶子进行计算，非叶子进行集合通信。建立两棵树是为了保证一个节点在一棵树中是叶子节点，在另一棵树中则是非叶节点；同时可以保证一个节点在两棵树中必定是共有两个父节点和两个子节点。另外就是更加高级和高性能的 Collnet，主打网内计算（In Network Computing），在传输的同时进行 reduce 操作。</p><p><img src="'+o+'" alt="image-20230322225016280"></p><p>接下来就是 NCCL 的大致工作流程：</p><p><img src="'+g+'" alt="image-20230322230710828"></p><p>最后讲了讲今年他们搞了什么新特性，宣传一波（求求别更新了，老代码还没看懂</p>',19),C=[l];function _(d,h,u,L,N,f){return a(),n("div",null,C)}const P=e(m,[["render",_]]);export{b as __pageData,P as default};
