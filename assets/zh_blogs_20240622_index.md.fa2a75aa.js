import{_ as e,c as p,o as i,e as a}from"./app.7e53e423.js";const t="/assets/1.bb0ca5bc.jpg",c="/assets/2.2afda617.jpg",r="/assets/3.fd34bc12.jpg",h="/assets/4.98c186dc.jpg",s="/assets/5.ba1dda9c.jpg",d="/assets/6.f9d6e26f.jpg",n="/assets/7.30bd52b1.jpg",A=JSON.parse('{"title":"AMD ROCm 源码阅读","description":"AMD YES ~","frontmatter":{"title":"AMD ROCm 源码阅读","description":"AMD YES ~","tags":["gpu"]},"headers":[{"level":2,"title":"hip_device.cpp","slug":"hip-device-cpp","link":"#hip-device-cpp","children":[]},{"level":2,"title":"hip_device_runtime.cpp","slug":"hip-device-runtime-cpp","link":"#hip-device-runtime-cpp","children":[]},{"level":2,"title":"hip_context.cpp","slug":"hip-context-cpp","link":"#hip-context-cpp","children":[]},{"level":2,"title":"hip_stream_ops.cpp","slug":"hip-stream-ops-cpp","link":"#hip-stream-ops-cpp","children":[]},{"level":2,"title":"hip_stream.cpp","slug":"hip-stream-cpp","link":"#hip-stream-cpp","children":[]},{"level":2,"title":"hip_table_interface.cpp","slug":"hip-table-interface-cpp","link":"#hip-table-interface-cpp","children":[]}],"relativePath":"zh/blogs/20240622/index.md"}'),l={name:"zh/blogs/20240622/index.md"},o=a('<nav class="table-of-contents"><ul><li><a href="#hip-device-cpp">hip_device.cpp</a></li><li><a href="#hip-device-runtime-cpp">hip_device_runtime.cpp</a></li><li><a href="#hip-context-cpp">hip_context.cpp</a></li><li><a href="#hip-stream-ops-cpp">hip_stream_ops.cpp</a></li><li><a href="#hip-stream-cpp">hip_stream.cpp</a></li><li><a href="#hip-table-interface-cpp">hip_table_interface.cpp</a></li></ul></nav><p><a href="https://github.com/ROCm/hipother" target="_blank" rel="noreferrer">https://github.com/ROCm/hipother</a> Hip 的 nvidia 头文件</p><p><a href="https://github.com/ROCm/clr" target="_blank" rel="noreferrer">https://github.com/ROCm/clr</a> hip/rocm release 6.2</p><h1 id="clr-hipamd-src" tabindex="-1">clr/hipamd/src/ <a class="header-anchor" href="#clr-hipamd-src" aria-hidden="true">#</a></h1><h2 id="hip-device-cpp" tabindex="-1">hip_device.cpp <a class="header-anchor" href="#hip-device-cpp" aria-hidden="true">#</a></h2><p>ihipDeviceGet 和 cuda 一样，默认 ordinal 就是 hipDevice_t</p><p><img src="'+t+'" alt=""></p><p>常规 API 和 graph API 的默认的 memory pool 是分开的。</p><p><img src="'+c+'" alt=""></p><p>在 stream 上做同步，是通过遍历每个 steram 上的 amd::Command，加入到一个列表里，然后实例化一个 amd::Marker 类型的 amd::Command，标识阻塞任务。 lambda 函数 waitForStream 捕获了当前上下文的 eventWaitList 和 submitMarker，累积需要同步的 event。 和 cuda 一样，stream 的同步，需要判断是不是特殊的 null stream。</p><p><img src="'+r+'" alt=""></p><h2 id="hip-device-runtime-cpp" tabindex="-1">hip_device_runtime.cpp <a class="header-anchor" href="#hip-device-runtime-cpp" aria-hidden="true">#</a></h2><p>device 对外的 api。比如 hipDeviceGetAttribute 会调用 device.cpp 里面的 ihipGetDeviceProperties。</p><h2 id="hip-context-cpp" tabindex="-1">hip_context.cpp <a class="header-anchor" href="#hip-context-cpp" aria-hidden="true">#</a></h2><p>rocm 创建 ctx，就是将 primary ctx 直接引用计数增加了一次。</p><p><img src="'+h+'" alt=""></p><p>hipCtxSynchronize 这个 API 看代码就是不支持， 难怪之前看 cuMemFree 的那个问题的时候，cuda 是按 ctx 做的同步，rocm 直接整个device 做的同步……不过这个也挺奇怪，为什么不直接调用下 hipDeviceSynchronize，而是抛个 not support 错误。</p><p><img src="'+s+'" alt=""></p><p>其实直接从下面这个 API 就可以看出来，对外的模糊结构体指针 hipCtx_t 本身就是一个 hip:Device 类型的指针，ctx 和 device 其实是不做区分的。</p><p><img src="'+d+'" alt=""></p><p>Amd 文档里倒是写明了 ctx 相关 api 并不是完全支持，但是这感觉在 cuda 12 的 green ctx 出来以后，兼容性会更加严重</p><p><img src="'+n+'" alt=""></p><p>也可以去看下 hipify 的兼容性文档 <a href="https://github.com/ROCm/HIPIFY/blob/455103c5428d3bf6dfe6351c93d7bde222bb9f86/docs/tables/CUDA_Driver_API_functions_supported_by_HIP.md" target="_blank" rel="noreferrer">https://github.com/ROCm/HIPIFY/blob/455103c5428d3bf6dfe6351c93d7bde222bb9f86/docs/tables/CUDA_Driver_API_functions_supported_by_HIP.md</a></p><h2 id="hip-stream-ops-cpp" tabindex="-1">hip_stream_ops.cpp <a class="header-anchor" href="#hip-stream-ops-cpp" aria-hidden="true">#</a></h2><p>实现 hip::ihipStreamOperation，构建 amd::StreamOperationCommand 类型的 amd::Command。</p><h2 id="hip-stream-cpp" tabindex="-1">hip_stream.cpp <a class="header-anchor" href="#hip-stream-cpp" aria-hidden="true">#</a></h2><h2 id="hip-table-interface-cpp" tabindex="-1">hip_table_interface.cpp <a class="header-anchor" href="#hip-table-interface-cpp" aria-hidden="true">#</a></h2><p>获取 HipCompilerDispatchTable 和 HipDispatchTable 上的函数指针。</p><p>搞这么一个 dispatch table 结构体让 API 维持稳定，参考 clr/hipamd/src/hip_api_trace.cpp</p><h1 id="clr-rocclr-platform-command-hpp" tabindex="-1">clr/rocclr/platform/command.hpp <a class="header-anchor" href="#clr-rocclr-platform-command-hpp" aria-hidden="true">#</a></h1><p>amd::Command 类型是提交给硬件 command 队列的类，抽象了所有OpenCL operations（因为 hip 后来才搞的，所以和 OpenCL 共用了这个类），提交给 HostQueue 执行。继承 amd::Command 的子类都需要实现 submit 接口。</p>',31),m=[o];function _(b,f,u,v,g,x){return i(),p("div",null,m)}const D=e(l,[["render",_]]);export{A as __pageData,D as default};
