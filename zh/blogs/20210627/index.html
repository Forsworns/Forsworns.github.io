<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>使用 libbpf-bootstrap 构建 BPF 应用程序 | Blog</title>
    <meta name="generator" content="VuePress 1.6.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/ionicons/2.0.1/css/ionicons.min.css">
    <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.5f87357d.css" as="style"><link rel="preload" href="/assets/js/app.8a71fa9b.js" as="script"><link rel="preload" href="/assets/js/1.0d3f5407.js" as="script"><link rel="preload" href="/assets/js/69.38117192.js" as="script"><link rel="preload" href="/assets/js/13.0b8f69bf.js" as="script"><link rel="prefetch" href="/assets/js/10.f185e824.js"><link rel="prefetch" href="/assets/js/11.5b47cb29.js"><link rel="prefetch" href="/assets/js/12.1aefa809.js"><link rel="prefetch" href="/assets/js/14.65c55c5b.js"><link rel="prefetch" href="/assets/js/15.6f479178.js"><link rel="prefetch" href="/assets/js/16.be0357cf.js"><link rel="prefetch" href="/assets/js/17.b23d5d24.js"><link rel="prefetch" href="/assets/js/18.a713061d.js"><link rel="prefetch" href="/assets/js/19.7cbdd573.js"><link rel="prefetch" href="/assets/js/20.2c8d9022.js"><link rel="prefetch" href="/assets/js/21.f832c1d5.js"><link rel="prefetch" href="/assets/js/22.d849a848.js"><link rel="prefetch" href="/assets/js/23.c7b0f8af.js"><link rel="prefetch" href="/assets/js/24.5cfa3357.js"><link rel="prefetch" href="/assets/js/25.5734f2a9.js"><link rel="prefetch" href="/assets/js/26.ec1f02c1.js"><link rel="prefetch" href="/assets/js/27.04ed5c55.js"><link rel="prefetch" href="/assets/js/28.59003c9a.js"><link rel="prefetch" href="/assets/js/29.a1596266.js"><link rel="prefetch" href="/assets/js/3.7e143bb3.js"><link rel="prefetch" href="/assets/js/30.2a986820.js"><link rel="prefetch" href="/assets/js/31.60fb3447.js"><link rel="prefetch" href="/assets/js/32.a4decb12.js"><link rel="prefetch" href="/assets/js/33.19c13d91.js"><link rel="prefetch" href="/assets/js/34.860038b3.js"><link rel="prefetch" href="/assets/js/35.9ff8afd6.js"><link rel="prefetch" href="/assets/js/36.98355663.js"><link rel="prefetch" href="/assets/js/37.5d6bfae5.js"><link rel="prefetch" href="/assets/js/38.410b61f3.js"><link rel="prefetch" href="/assets/js/39.2b6de04b.js"><link rel="prefetch" href="/assets/js/4.a6d4f924.js"><link rel="prefetch" href="/assets/js/40.380a085f.js"><link rel="prefetch" href="/assets/js/41.40b7b75e.js"><link rel="prefetch" href="/assets/js/42.28f14454.js"><link rel="prefetch" href="/assets/js/43.4d0cea48.js"><link rel="prefetch" href="/assets/js/44.9059c3cf.js"><link rel="prefetch" href="/assets/js/45.a469afec.js"><link rel="prefetch" href="/assets/js/46.47f55f41.js"><link rel="prefetch" href="/assets/js/47.27371930.js"><link rel="prefetch" href="/assets/js/48.e3782d4a.js"><link rel="prefetch" href="/assets/js/49.2a7cec5c.js"><link rel="prefetch" href="/assets/js/5.9d9ce47c.js"><link rel="prefetch" href="/assets/js/50.bad172c2.js"><link rel="prefetch" href="/assets/js/51.6ca67f11.js"><link rel="prefetch" href="/assets/js/52.07534a08.js"><link rel="prefetch" href="/assets/js/53.fc2e98e5.js"><link rel="prefetch" href="/assets/js/54.ae56cb99.js"><link rel="prefetch" href="/assets/js/55.caa38232.js"><link rel="prefetch" href="/assets/js/56.3895da78.js"><link rel="prefetch" href="/assets/js/57.c618137d.js"><link rel="prefetch" href="/assets/js/58.83219ae3.js"><link rel="prefetch" href="/assets/js/59.3f6fda66.js"><link rel="prefetch" href="/assets/js/6.ede0ec8a.js"><link rel="prefetch" href="/assets/js/60.71fee065.js"><link rel="prefetch" href="/assets/js/61.86cb3713.js"><link rel="prefetch" href="/assets/js/62.3ccc2745.js"><link rel="prefetch" href="/assets/js/63.7f37832d.js"><link rel="prefetch" href="/assets/js/64.fbf5c608.js"><link rel="prefetch" href="/assets/js/65.b2da7c8b.js"><link rel="prefetch" href="/assets/js/66.969a1abc.js"><link rel="prefetch" href="/assets/js/67.ecd64256.js"><link rel="prefetch" href="/assets/js/68.16b99a64.js"><link rel="prefetch" href="/assets/js/7.a7a745d5.js"><link rel="prefetch" href="/assets/js/70.caf9f72d.js"><link rel="prefetch" href="/assets/js/71.e64ce24a.js"><link rel="prefetch" href="/assets/js/72.9dfc7344.js"><link rel="prefetch" href="/assets/js/73.ef6a84f4.js"><link rel="prefetch" href="/assets/js/74.a751b7c0.js"><link rel="prefetch" href="/assets/js/75.a2c6c957.js"><link rel="prefetch" href="/assets/js/76.ba83a835.js"><link rel="prefetch" href="/assets/js/77.6524eeb6.js"><link rel="prefetch" href="/assets/js/78.c502106b.js"><link rel="prefetch" href="/assets/js/8.b248f5c8.js"><link rel="prefetch" href="/assets/js/9.067e129a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5f87357d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zh/" class="home-link router-link-active"><img src="/title.png" alt="Blog" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zh/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/zh/about-me/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客" class="mobile-dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zh/blogs/" class="nav-link router-link-active">
  所有博客
</a></li><li class="dropdown-item"><!----> <a href="/zh/blogs/category/" class="nav-link">
  标签分类
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">选择语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Select language" class="mobile-dropdown-title"><span class="title">选择语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/zh/blogs/20210627/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  简体中文
</a></li></ul></div></div> <a href="https://github.com/Forsworns/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zh/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/zh/about-me/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="博客" class="mobile-dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zh/blogs/" class="nav-link router-link-active">
  所有博客
</a></li><li class="dropdown-item"><!----> <a href="/zh/blogs/category/" class="nav-link">
  标签分类
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">选择语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Select language" class="mobile-dropdown-title"><span class="title">选择语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/zh/blogs/20210627/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  简体中文
</a></li></ul></div></div> <a href="https://github.com/Forsworns/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#为什么使用-libbpf-bootstrp">为什么使用 libbpf-bootstrp？</a></li><li><a href="#背景">背景</a></li><li><a href="#libbpf-bootstrap-概览">Libbpf-bootstrap 概览</a></li><li><a href="#minimal-app">Minimal app</a><ul><li><a href="#the-bpf-side">The BPF side</a></li><li><a href="#the-user-space-side">The user-space side</a></li></ul></li><li><a href="#makefile">Makefile</a></li><li><a href="#bootstrap-app">Bootstrap app</a><ul><li><a href="#includes-vmlinux-h-libbpf-and-app-headers">Includes: vmlinux.h, libbpf and app headers</a></li><li><a href="#bpf-maps">BPF maps</a></li><li><a href="#bpf-ring-buffer">BPF ring buffer</a></li><li><a href="#bpf-co-re">BPF CO-RE</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#补充-bpf-map-相关内容">补充 BPF Map 相关内容</a><ul><li><a href="#使用bpf系统调用操作-bpf-maps">使用BPF系统调用操作 BPF maps</a></li><li><a href="#使用-bpf-helper-创建bpf-maps">使用 BPF helper 创建BPF maps</a></li><li><a href="#working-with-bfp-maps">Working with BFP Maps</a></li><li><a href="#更新元素">更新元素</a></li><li><a href="#读取元素">读取元素</a></li><li><a href="#删除元素">删除元素</a></li><li><a href="#迭代遍历元素">迭代遍历元素</a></li><li><a href="#查找删除元素">查找删除元素</a></li><li><a href="#并发访问-map">并发访问 map</a></li></ul></li></ul></div><p></p> <h1 id="使用-libbpf-bootstrap-构建-bpf-程序"><a href="#使用-libbpf-bootstrap-构建-bpf-程序" class="header-anchor">#</a> 使用 libbpf-bootstrap 构建 BPF 程序</h1> <p>libbpf 是一个比 <a href="https://github.com/iovisor/bcc/" target="_blank" rel="noopener noreferrer">BCC<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>  更新的 BPF 开发库，也是最新的 BPF 开发推荐方式，官方提供了 <a href="https://github.com/libbpf/libbpf" target="_blank" rel="noopener noreferrer">C<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://github.com/libbpf/libbpf-rs" target="_blank" rel="noopener noreferrer">Rust<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的库实现。libbpf 支持最新的 BPF CO-RE 特性（单次编译到处执行），它不像 BCC 依赖于 Clang/LLVM 运行时，也不是通过封装后的 Python 接口书写而是直接使用 C 或 Rust 进行开发，也不需要内核开发头文件。所以转向 libbpf 的使用吧。为了方便初学者和习惯了 BCC 的开发者，官方提供了 <a href="https://github.com/libbpf/libbpf-bootstrap" target="_blank" rel="noopener noreferrer">libbpf-bootstrap<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 示例项目，BCC 项目里也有一些用 libbpf 构建的工具 <a href="https://github.com/iovisor/bcc/tree/master/libbpf-tools" target="_blank" rel="noopener noreferrer">bcc/libbpf-tools<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>下面的内容翻译自相关<a href="https://nakryiko.com/posts/libbpf-bootstrap/" target="_blank" rel="noopener noreferrer">博客：Building BPF applications with libbpf-bootstrap<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>使用 <a href="https://github.com/libbpf/libbpf-bootstrap" target="_blank" rel="noopener noreferrer">libbpf-bootstrap<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 脚手架项目快速上手 libbpf，该项目已经配置好了环境，能够让开发者直接找到 BPF 的乐趣所在。下面我们将一起查看 libbpf-bootstrap 到底干了些什么，以及这一切是如何发挥作用的。</p> <h2 id="为什么使用-libbpf-bootstrp"><a href="#为什么使用-libbpf-bootstrp" class="header-anchor">#</a> 为什么使用 libbpf-bootstrp？</h2> <p>BPF 是一种令人惊异的内核技术，它能够让开发者一览内核函数是如何工作的，即使该开发者没有内核开发的经验，也不需要该开发者花费大量时间在内核开发环境配置上。BPF 也降低了在检阅内核工作状态时 OS 崩溃的风险。一旦你掌握了 BPF，你就会了解其中的乐趣和它无穷的能力。</p> <p>但是 BPF 的起步对很多人来说，仍然会是一个令人生畏的环节。因为构建一个 BPF 应用程序的工作流，即使是一个 “hello world” 程序都需要大量的步骤。这会是令人失望的，而且会吓走一大片开发者。这个过程不难，但是知晓其中必要的步骤仍然可能会劝退很多人，即使他们知道 BPF 的威力。</p> <p><a href="https://github.com/libbpf/libbpf-bootstrap" target="_blank" rel="noopener noreferrer">libbpf-bootstrap<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 就是这样一个 BPF 游乐场，它已经尽可能地为初学者配置好了环境，帮助他们可以直接步入到 BPF 程序的书写。它综合了 BPF 社区多年来的最佳实践，并且提供了一个现代化的、便捷的工作流。libbpf-bootstrap 依赖于 libbpf 并且使用了一个很简单的 Makefile。对于需要更高级设置的用户，它也是一个好的起点。即使这个 Makefile不会被直接使用到，也可以很轻易地迁移到别的构建系统上。</p> <p>libbpf-bootstrap 中有两个示例 BPF 程序（目前已经不止这两个了）： <code>minimal</code> 和 <code>bootstrap</code>。<code>minimal</code> 是能够编译、加载和运行的最小化的 BPF 程序，它做的就是 BPF 中等价的<code>printf(&quot;Hello, World!&quot;)</code>。既然是最小化的一个程序，它也不会依赖于很新的内核特性，即使是旧的内核版本，它也应该会正常工作。</p> <p>运行 <code>minimal</code> 示例可以很快地在本地完成一个小的测试，但是它不能反映出用于生产环境下的 BPF 程序是否在各种各样的内核上都是可以使用的。<code>bootstrap</code> 是一个这样的示例，它构建了一个最小化的可迁移的 BPF 程序。为了满足这个需求，它依赖于 <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/" target="_blank" rel="noopener noreferrer">BPF CO-RE<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 特性和内核的 <a href="https://nakryiko.com/posts/btf-dedup/" target="_blank" rel="noopener noreferrer">BTF<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 支持，所以确保你的 Linux 内核在构建的时候选择了<code>CONFIG_DEBUG_INFO_BTF=y</code> 内核选项。可以参考 <a href="https://github.com/libbpf/libbpf#bpf-co-re-compile-once--run-everywhere" target="_blank" rel="noopener noreferrer">libbpf README<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，查阅已经配置好这些的 Linux 发行版。如果你想要减少构建自定义内核的麻烦，就尽可能地使用更新的内核吧。</p> <p>另外，<code>bootstrap</code> 还演示了 BPF 全局变量（Linux 5.5+）和 <a href="https://nakryiko.com/posts/bpf-ringbuf" target="_blank" rel="noopener noreferrer">BPF ring buffer<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Linux 5.8+）的使用。这些特性不是构建 BPF 程序必要的组件，但是他们带来了巨大的可用性提升和更现代化的 BPF 程序开发方法，所以他们被加入到了这个示例中。</p> <h2 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h2> <p>BPF 是一个持续演进的技术，这意味着新特性将会被持续添加进来，所以视你要采用的 BPF 特性，你可能需要更新的内核版本。但是 BPF 社区非常严肃地考虑了后向兼容性，所以旧的内核仍然可以运行 BPF 程序，假如你不需要新功能的话。所以你的 BPF 程序的逻辑越简单，特性越少，你的 BPF 程序就可以运行在越旧的内核上。</p> <p>BPF 的用户体验是一直在提升的，更新的内核版本中的 BPF 提供了更加巨大的易用性上的改进。所以如果你只是刚起步，不需要支持旧版的内核，还是用最新的内核吧，让自己少掉点头发。</p> <p>BPF 程序一般是用 C 语言写的，会有一些代码结构方面的拓展，来让 <a href="https://github.com/libbpf/libbpf" target="_blank" rel="noopener noreferrer">libbpf<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 知晓 BPF 代码的结构，更高效地处理他们，<a href="https://clang.llvm.org/" target="_blank" rel="noopener noreferrer">Clang<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是 BPF 代码编译推荐使用的编译器，通常也会推荐使用最新的 Clang。Clang 10 或者更新的版本能够处理大多数的 BPF 特性，但是更先进的 <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/" target="_blank" rel="noopener noreferrer">BPF CO-RE<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 特性需要 Clang 11 甚至是 Clang 12（例如，一些最近的 CO-RE relocation built-ins）。</p> <p>libbpf-bootstrap 打包了 libbpf （作为一个 Git submodule）和 bpftool （只适用于 x86-64 体系）来避免任何你的某个特定 Linux 发行版的依赖需求。<strong>你的系统需要安装 <code>zlib</code> (<code>libz-dev</code> 或 <code>zlib-devel</code> 包) 和<code>libelf</code> (<code>libelf-dev</code> 或 <code>elfutils-libelf-devel</code> package) 。这些是 <code>libbpf</code> 编译和正确运行的必要依赖</strong>，（注意对于 BTF 的支持情况，需要参考官方文档或之前的<a href="/zh/blogs/20210311/#libbpf">笔记</a>，只有较新的发行版直接暴露了 BTF 到 <code>/sys/kernel/btf/vmlinux</code>）。</p> <p>这篇文章不是 BPF 技术的入门介绍，所以假定读者已经知晓了基本的概念，比如 BPF program，BPF map，BPF hooks (attach points) 。如果你需要重温一下基础知识，可以看<a href="https://docs.cilium.io/en/latest/bpf/" target="_blank" rel="noopener noreferrer">这些<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/" target="_blank" rel="noopener noreferrer">资料<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>下面将会详细介绍 <a href="https://github.com/libbpf/libbpf-bootstrap" target="_blank" rel="noopener noreferrer">libbpf-bootstrap<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的结构，它的 Makefile 和 <code>minimal</code> 、<code>bootstrap</code> 两个示例。我们将会了解 libbpf 的代码风格，了解如何把 BPF C 程序构建成使用 libbpf 作为 BPF program loader 的形式，以及如何使用用户空间的 libbpf API 和你的 BPF 程序交互。</p> <h2 id="libbpf-bootstrap-概览"><a href="#libbpf-bootstrap-概览" class="header-anchor">#</a> Libbpf-bootstrap 概览</h2> <p>下面就是 <a href="https://github.com/libbpf/libbpf-bootstrap" target="_blank" rel="noopener noreferrer"><code>libbpf-bootstrap</code><svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的目录结构</p> <div class="language- extra-class"><pre class="language-text"><code>$ tree
.
├── libbpf
│   ├── ...
│   ... 
├── LICENSE
├── README.md
├── src
│   ├── bootstrap.bpf.c
│   ├── bootstrap.c
│   ├── bootstrap.h
│   ├── Makefile
│   ├── minimal.bpf.c
│   ├── minimal.c
│   ├── vmlinux_508.h
│   └── vmlinux.h -&gt; vmlinux_508.h
└── tools
    ├── bpftool
    └── gen_vmlinux_h.sh

16 directories, 85 files
</code></pre></div><p><code>libbpf-bootstrap</code> 把 libbpf 打包成了 <code>libbpf/</code> 子目录下的一个子模块来避免系统侧对 libbpf 的依赖。</p> <p><code>tools/</code> 包含了 <code>bpftool</code> 的二进制文件，用来构建你的 BPF 程序的  <a href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/#bpf-skeleton-and-bpf-app-lifecycle" target="_blank" rel="noopener noreferrer">BPF skeletons<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。 类似 libbpf，它被打包进来以避免依赖问题。</p> <p>另外， bpftool 能被用来生成你自己的包含内核类型定义的 <code>vmlinux.h</code>头文件。 一般来说你不需要这么做，因为 libbpf-bootstrap 已经在 <code>src/</code> 子目录下提供了预先生成的  <a href="https://raw.githubusercontent.com/libbpf/libbpf-bootstrap/master/src/vmlinux_508.h" target="_blank" rel="noopener noreferrer">vmlinux.h<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。 它基于 Linux 5.8 内核选项的默认设置，激活了一些额外的和 BPF 相关的功能的配置项。这意味着它已经有了一些通用的内核类型和常量。因为有  <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/" target="_blank" rel="noopener noreferrer">BPF CO-RE<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>， <code>vmlinux.h</code> 不需要特定地去匹配你的内核配置和版本。但是如果你仍然要生成你自己的 <code>vmlinux.h</code>，尽管参考 <a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/tools/gen_vmlinux_h.sh" target="_blank" rel="noopener noreferrer"><code>tools/gen_vmlinux_h.sh</code><svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 脚本吧，去看看它是如何做的。</p> <p><a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/src/Makefile" target="_blank" rel="noopener noreferrer">Makefile<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 定义了必要的构建规则，来编译所有提供的 BPF 应用。它遵从一个简单的文件命名规则。</p> <ul><li><code>&lt;app&gt;.bpf.c</code> 文件是 BPF C 代码包含了将在内核上下文中执行的逻辑。</li> <li><code>&lt;app&gt;.c</code> 是用户空间的 C 代码，加载了 BPF 代码，在应用的整个生命周期内和它交互。</li> <li><em>optional</em> <code>&lt;app&gt;.h</code> 是一个头文件，包含了常见的类型定义，是在 BPF 代码和用户空间代码之间共享的。</li></ul> <h2 id="minimal-app"><a href="#minimal-app" class="header-anchor">#</a> Minimal app</h2> <p><code>minimal</code> 是一个给初学者的很好的例子。它是一个最小化的 BPF 试验场所。它不使用 CO-RE 特性，所以你可以在旧些的内核上使用它，只需要 include 你的内核类型定义。这个例子不适合拿来做生产环境下用，但是做学习用途还是很好的。</p> <h3 id="the-bpf-side"><a href="#the-bpf-side" class="header-anchor">#</a> The BPF side</h3> <p>下面就是 BPF 侧的代码 (<a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/src/minimal.bpf.c" target="_blank" rel="noopener noreferrer">minimal.bpf.c<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) ：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause</span>
<span class="token comment">/* Copyright (c) 2020 Facebook */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/bpf.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bpf/bpf_helpers.h&gt;</span></span>

<span class="token keyword">char</span> LICENSE<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">SEC</span><span class="token punctuation">(</span><span class="token string">&quot;license&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;Dual BSD/GPL&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> my_pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">SEC</span><span class="token punctuation">(</span><span class="token string">&quot;tp/syscalls/sys_enter_write&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> <span class="token function">handle_tp</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">bpf_get_current_pid_tgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> my_pid<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token function">bpf_printk</span><span class="token punctuation">(</span><span class="token string">&quot;BPF triggered from PID %d.\n&quot;</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>#include &lt;linux/bpf.h&gt;</code> 导入了一些基础的、必要的 BPF 相关的类型和常量，以便使用内核侧的 BPF API，例如 BPF helper function flags。这个头文件是之后导入 <code>bpf_helpers.h</code> 这个头文件所必须的前提。而 <code>bpf_helpers.h</code> 是由 <code>libbpf</code> 提供的，包含了大多数常用的宏、常量和 BPF helper 的定义，几乎会在每个 BPF 应用中用到。例如上面用到的<code>bpf_get_current_pid_tgid()</code> 就是一个 BPF helper。</p> <p><code>LICENSE</code> 变量定义了你的 BPF 代码的 license。在内核开发中，明确 license 是必须的。一些 BPF 功能对于不兼容 GPL 的代码是不可用的。注意特殊的 <code>SEC(&quot;license&quot;)</code> 注解。 定义在 <code>bpf_helpers.h</code> 中的 <code>SEC()</code>  把变量和函数放到了特殊的段中。 <code>SEC(&quot;license&quot;)</code> 和一些其他的段名，是 libbpf 规定的，只要遵循就好了。</p> <p>接下来，我们看看 BPF 特性“全局变量”是如何使用的。代码 <code>int my_pid = 0;</code> 所做的正是你所想象的事情：它定义了一个全局变量，BPF 代码可以读取和更新它，就像其他用户空间的 C 代码对待全局变量那样。使用 BPF 全局变量维护程序的状态很方便，而且性能表现也不错。另外，这样的全局变量能够从用户侧读写。这个特性是从 Linux 5.5 之后才支持的。在用额外的设置项配置 BPF 程序的时候常常会用到它。它也经常用于在内核中的 BPF 代码和用户侧的控制代码之间传递数据。</p> <p><code>SEC(&quot;tp/syscalls/sys_enter_write&quot;) int handle_tp(void *ctx) { ... }</code> 定义了 BPF 程序，它会被加载到内核中。它是由一个普通的 C 函数定义的，使用 <code>SEC()</code> 宏放在一个特殊的段中。段名定义了 libbpf 程序创建的是什么类型的 BPF 程序，以及它是附着到内核上哪个地方的。在这个例子中，我们是定义了一个 tracepoint BPF 程序，每次用户空间的应用调用了系统调用 <code>write()</code> 的时候，就会触发它。</p> <blockquote><p>在同一个 BPF C 程序文件中，可能有多个 BPF 程序。他们可以是不同类型的，有着不同的 <code>SEC()</code> 宏。例如，你可以用不同的 BPF 程序追踪不同的系统调用或其他事件（如网络包的处理）。你也可以使用相同的 <code>SEC()</code> 宏来定义多个 BPF 程序，libbpf 会自动处理他们。在同一个 BPF C 代码文件中的所有的 BPF 程序共享所有的全局状态，例如上面例子中的 <code>my_pid</code> 变量，如果使用了 BPF map，它也是共享的。这常常用在 BPF 程序的协作中。</p></blockquote> <p>下面仔细看看 BPF 程序 <code>handle_tp</code> 是在干嘛：</p> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">bpf_get_current_pid_tgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> my_pid<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>这部分获取了 PID，或者说是内核术语中的 &quot;TGID&quot; ，它存储在 <code>bpf_get_current_pid_tgid()</code> 返回值的高 32 位。接着，它会查看触发了 <code>write()</code> 系统调用的进程是否是我们的 <code>minimal</code> 进程。这对于一个很繁忙的系统是十分重要的，因为很可能有大量不相关的进程触发了 <code>write()</code>，使得你很难用这段 BPF 代码进行实验得到预期的结果。全局变量 <code>my_pid</code> 是通过下面的用户空间的代码进行初始化的，它会被初始化成真实的 PID 值。</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token function">bpf_printk</span><span class="token punctuation">(</span><span class="token string">&quot;BPF triggered from PID %d.\n&quot;</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这就是 BPF 中的 <code>printf(&quot;Hello, world!\n&quot;)</code>。它输出格式化的字符串到一个特殊的文件，叫作 <code>/sys/kernel/debug/tracing/trace_pipe</code>，你可以从控制台中去查看它的内容，注意你需要 <code>sudo</code> 来取得查看它的权限：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">cat</span> /sys/kernel/debug/tracing/trace_pipe
	<span class="token operator">&lt;</span><span class="token punctuation">..</span>.<span class="token operator">&gt;</span>-3840345 <span class="token punctuation">[</span>010<span class="token punctuation">]</span> d<span class="token punctuation">..</span>. <span class="token number">3220701.101143</span>: bpf_trace_printk: BPF triggered from PID <span class="token number">3840345</span>.
	<span class="token operator">&lt;</span><span class="token punctuation">..</span>.<span class="token operator">&gt;</span>-3840345 <span class="token punctuation">[</span>010<span class="token punctuation">]</span> d<span class="token punctuation">..</span>. <span class="token number">3220702.101265</span>: bpf_trace_printk: BPF triggered from PID <span class="token number">3840345</span>.
</code></pre></div><blockquote><p><code>bpf_printk()</code> 帮助函数和 <code>trace_pipe</code> 文件一般不在生产环境中使用，它们是用来辅助 BPF 程序的 debug 的，帮助开发者知道自己的代码到底干了些什么事情。目前还没有 BPF 的调试工具，所以这种输出调试是目前最方便的调试方法了。</p></blockquote> <p>这就是 BPF 侧的 <code>minimal</code> 应用了，你可以加一些别的代码到 <code>handle_tp()</code> 中，按你所需去拓展它。</p> <h3 id="the-user-space-side"><a href="#the-user-space-side" class="header-anchor">#</a> The user-space side</h3> <p>让我们看看用户空间到底做了啥 (<a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/src/minimal.c" target="_blank" rel="noopener noreferrer">minimal.c<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)，我们会跳过一些显然的部分，但是无论如何，读者都应该去看一下完整的代码。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;minimal.skel.h&quot;</span></span>
</code></pre></div><p>这里导入了 BPF 代码 <code>minimal.bpf.c</code> 中的 BPF skeleton。它是在 Makefile中的某一步，由 bpftool 自动生成的文件，它高度抽象了<code>minimal.bpf.c</code> 的结构。它也简化了 BPF 代码部署的逻辑，将编译出的 BPF 目标代码嵌入到了头文件中，该头文件又会被用户空间的代码所引用。你的应用程序的二进制文件中不会有其他多余的文件了，就导入它就好了。</p> <blockquote><p>BPF skeleton 是完全由 <code>libbpf</code> 构造出的，内核对它一无所知。但是它的存在显著提升了 BPF 开发体验，所以, 最好熟悉一下它。可以看这篇 <a href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/#bpf-skeleton-and-bpf-app-lifecycle" target="_blank" rel="noopener noreferrer">博客<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来了解 BPF skeleton 的细节。</p></blockquote> <p>libbpf-bootstrap 的 BPF skeletons 在成功 <code>make</code> 后，生成到了 <code>src/.output/&lt;app&gt;.skel.h</code> 中。为了获取直观感受，下面是 <code>minimal.bpf.c</code> 的 skeletons 高度抽象后的概览：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */</span>

<span class="token comment">/* THIS FILE IS AUTOGENERATED! */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MINIMAL_BPF_SKEL_H__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MINIMAL_BPF_SKEL_H__</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bpf/libbpf.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">bpf_object_skeleton</span> <span class="token operator">*</span>skeleton<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">bpf_object</span> <span class="token operator">*</span>obj<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">bpf_map</span> <span class="token operator">*</span>bss<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> maps<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">bpf_program</span> <span class="token operator">*</span>handle_tp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> progs<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">bpf_link</span> <span class="token operator">*</span>handle_tp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> links<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">minimal_bpf__bss</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> my_pid<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token operator">*</span>bss<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">minimal_bpf__destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span><span class="token function">minimal_bpf__open_opts</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">bpf_object_open_opts</span> <span class="token operator">*</span>opts<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span><span class="token function">minimal_bpf__open</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">minimal_bpf__load</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span><span class="token function">minimal_bpf__open_and_load</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">minimal_bpf__attach</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">minimal_bpf__detach</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* __MINIMAL_BPF_SKEL_H__ */</span></span>
</code></pre></div><p>上面的自动生成的代码中，会有一个 <code>struct bpf_object *obj;</code> ，它会被传递给 libbpf 的 API。它也包含有 <code>maps</code>， <code>progs</code> 和 <code>links</code> 等段，可以直接获取到你的 BPF 代码中定义的 BPF map 和程序。例如，前面提到的 BPF 程序 <code>handle_tp</code> 。这些引用能够直接传递给 libbpf的 API 去完成 BPF map/program/link 相关的工作。Skeleton 也可以包含可选的 bss、data、rodata 段，从而可以直接从用户空间访问 BPF 全局变量而不必使用额外的系统调用。在这种情况下，我们的<code>my_pid</code> BPF 变量对应的是 <code>bss-&gt;my_pid</code> 域。</p> <p>现在看看  <code>minimal</code> 应用的 <code>main()</code> 函数在干些什么：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">minimal_bpf</span> <span class="token operator">*</span>skel<span class="token punctuation">;</span>
	<span class="token keyword">int</span> err<span class="token punctuation">;</span>

	<span class="token comment">/* Set up libbpf errors and debug info callback */</span>
	<span class="token function">libbpf_set_print</span><span class="token punctuation">(</span>libbpf_print_fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>libbpf_set_print()</code> 提供了一个自定义的回调给所有的 libbpf 日志输出。这很有用，特别是在活跃的开发时期，因为它允许捕获有用的 libbpf 调试日志。默认情况下，libbpf 将只打印错误级别的信息。调试日志则会帮助我们更快地定位问题。</p> <blockquote><p>想报告 libbpf 或你的基于 libbpf 开发的应用的问题，可以发送邮件到 <a href="mailto://bpf@vger.kernel.org">bpf@vger.kernel.org</a> 邮件列表，记得附上你的调试信息。</p></blockquote> <p>在 <code>minimal</code> 这个示例中， <code>libbpf_print_fn()</code>  只是把所有内容都打印到标准输出 stdout。</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token comment">/* Bump RLIMIT_MEMLOCK to allow BPF sub-system to do anything */</span>
	<span class="token function">bump_memlock_rlimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这是一步令人困惑但也是必要的步骤，大多数 BPF 程序都要这么去做。它放松了内核中对每个用户内存的约束，允许 BPF 子系统分配必要的资源给你的 BPF 程序和 BPF maps 等。这个限制很可能会被马上移除掉，但是目前你需要打开这个内存限制，即 <code>RLIMIT_MEMLOCK</code> <a href="https://man7.org/linux/man-pages/man2/getrlimit.2.html" target="_blank" rel="noopener noreferrer">limit<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。通过 <code>minimal</code> 代码中使用的 <code>setrlimit(RLIMIT_MEMLOCK, ...)</code> ，是最简单也最便捷的方法。</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token comment">/* Load and verify BPF application */</span>
	skel <span class="token operator">=</span> <span class="token function">minimal_bpf__open_and_load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">&quot;Failed to open and load BPF skeleton\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>现在，使用自动生成的 BPF skeleton，加载 BPF 程序到内核中，然后让 BPF verifier 校验它是否合法，如果这步成功了，你的 BPF 代码就是正确的，而且可以附着到任何一个你需要的 BPF hook 上。</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token comment">/* ensure BPF program only handles write() syscalls from our process */</span>
	skel<span class="token operator">-&gt;</span>bss<span class="token operator">-&gt;</span>my_pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但是首先，我们需要与 BPF 交流我们的用户态程序的 PID，以便它能够过滤掉不相关的进程触发的 <code>write()</code>事件。上面的这行代码会直接设置映射过的内存区域的 BPF 全局变量 <code>my_pid</code>。如上面提到的，这就是用户态读写 BPF 全局变量的方式。</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token comment">/* Attach tracepoint handler */</span>
	err <span class="token operator">=</span> <span class="token function">minimal_bpf__attach</span><span class="token punctuation">(</span>skel<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">&quot;Failed to attach BPF skeleton\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Successfully started!\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>终于，我们可以将 BPF 程序<code>handle_tp</code> 附着到到内核的锚点上（即上面的 BPF hook）。BPF 程序会随之响应，内核会开始在内核上下文中，回应每个 <code>write()</code> 系统调用，执行我们自定义的 BPF 代码。</p> <blockquote><p>通过查看 <code>SEC()</code> 注解，libbpf 能够自动决定在什么地方附着 BPF 程序。这并非对所有类型的 BPF 程序都适用，但是对大多数还是适用的，比如：tracepoints、kprobes 等等（具体的 BPF 程序种类，可以参考之前的<a href="/zh/blogs/20210329/#常见-bpf-prog-type-定义">笔记</a>）。另外，libbpf 提供了额外的 API 来附着 BPF 程序，可以通过用户的编程实现。</p></blockquote> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">/* trigger our BPF program */</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>上面代码中的无穷循环确保了 BPF 程序 <code>handle_tp</code> 能够一直附着在内核中，直到用户关掉进程，如按下 <code>Ctrl-C</code>。同时，它还会周期性地（每秒）调用 <code>fprintf(stderr, ...)</code>，从而触发一次 <code>write()</code> 系统调用。通过这种方法，可以通过 <code>handle_tp</code> 监控内核的内部情况和状态随时间的变化。</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code><span class="token symbol">cleanup</span><span class="token punctuation">:</span>
	minimal_bpf__destroy<span class="token punctuation">(</span>skel<span class="token punctuation">)</span><span class="token punctuation">;</span>
	return -err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果前面任一个步骤错误了，<code>minimal_bpf__destroy()</code> 将会像上面这几行代码所述，在内核和用户空间清除所有的资源。这是一个好习惯，但是即使你的程序还没清理就崩溃了，内核也仍然能够清理掉资源。好吧，至少大多数情况下是这样的。也有一些类型的 BPF 程序，会在内核中一直保持活跃，即使它自己的用户空间的进程已经结束了。所以必要的话还是确保你检查过释放掉资源了。这就是 <code>minimal</code> 应用的全部的内容了，使用了 BPF skeleton 后，这一切都是很直截了当的。</p> <h2 id="makefile"><a href="#makefile" class="header-anchor">#</a> Makefile</h2> <p>既然我们已经浏览过了 <code>minimal</code> 应用，我们已经有足够的知识来看看 <a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/src/Makefile" target="_blank" rel="noopener noreferrer">Makefile<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 到底干了些什么。我们将跳过样板部分，关注核心的部分。</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code>INCLUDES <span class="token operator">:=</span> -I<span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>
CFLAGS <span class="token operator">:=</span> -g -Wall
ARCH <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">shell</span> uname -m <span class="token operator">|</span> sed <span class="token string">'s/x86_64/x86/'</span><span class="token punctuation">)</span>
</code></pre></div><p>这里我们定义一些在编译时使用的额外的参数。默认情况下，所有的中间文件都会写入到 <code>src/.output/</code> 子文件夹下。所以这个文件夹会被添加到 C 编译器的包含路径中，以便找到 BPF skeletons 和 libbpf 头文件。所有的用户空间文件在编译时都会带有调试信息（即 <code>-g</code> 选项），并且不会有任何的优化，来简化调试工作。 <code>ARCH</code> 参数捕获了宿主机的操作系统的架构，之后和定义在 libbpf 库中<code>bpf_tracing.h</code> 底层的 tracing helper 宏一起被传入到 BPF 代码编译步骤中。</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code>APPS <span class="token operator">=</span> minimal bootstrap
</code></pre></div><p>这里提供了目标的应用名称，添加到 <code>APPS</code> 变量中的会被编译。每个应用都定义了相关的 make 目标，所以你可以通过下面的命令构建对应的文件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">make</span> minimal
</code></pre></div><p>整个构建的过程分为下面的几步。首先，libbpf 以一个静态库的形式构建，它的 API 头文件之后被安装到了 <code>.output/</code> 中：</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code><span class="token comment"># Build libbpf</span>
<span class="token symbol"><span class="token variable">$</span>(LIBBPF_OBJ)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> <span class="token variable">$</span><span class="token punctuation">(</span>LIBBPF_SRC<span class="token punctuation">)</span>/*.[ch] <span class="token variable">$</span><span class="token punctuation">(</span>LIBBPF_SRC<span class="token punctuation">)</span>/Makefile<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>/libbpf
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> msg,LIB,<span class="token variable">$@</span><span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>LIBBPF_SRC<span class="token punctuation">)</span> BUILD_STATIC_ONLY<span class="token operator">=</span>1		      \
		    OBJDIR<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span>/libbpf DESTDIR<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span>		      \
		    INCLUDEDIR<span class="token operator">=</span> LIBDIR<span class="token operator">=</span> UAPIDIR<span class="token operator">=</span>			      \
		    install
</code></pre></div><p>如果你想要构建系统层面的共享库 <code>libbpf</code> ，你可以移除上面的步骤，然后对应地调整编译规则。</p> <p>下一步构建了 BPF C 代码，即 <code>*.bpf.c</code>，编译到了一个目标文件：</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code><span class="token comment"># Build BPF code</span>
<span class="token symbol"><span class="token variable">$</span>(OUTPUT)/%.bpf.o</span><span class="token punctuation">:</span> %.bpf.c <span class="token variable">$</span><span class="token punctuation">(</span>LIBBPF_OBJ<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> %.h<span class="token punctuation">)</span> vmlinux.h <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> msg,BPF,<span class="token variable">$@</span><span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CLANG<span class="token punctuation">)</span> -g -O2 -target bpf -D__TARGET_ARCH_<span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>INCLUDES<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %.c,<span class="token variable">$^</span><span class="token punctuation">)</span> -o <span class="token variable">$@</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>LLVM_STRIP<span class="token punctuation">)</span> -g <span class="token variable">$@</span> <span class="token comment"># strip useless DWARF info</span>
</code></pre></div><p>我们使用 Clang 来编译， <code>-g</code> 是必须的选项，来让 Clang 生成 BTF 相关的调试信息。 <code>-O2</code> 也是 BPF 编译中必要的， <code>-D__TARGET_ARCH_$(ARCH)</code> 为 <code>bpf_tracing.h</code> 定义了必要的宏来处理底层的 <code>struct pt_regs</code> 宏。你可以忽略它如果你不是在处理内核探测程序 kprobes 和 <code>struct pt_regs</code>。最后，我们从生成的 <code>.o</code> 文件中去除掉 DWARF 信息。因为它不会被用到，基本上都是 Clang 编译的副产物。</p> <blockquote><p>BTF 是确保 BPF 正常工作的唯一的必要信息，因此会被保留下来。减小最终的  <code>.bpf.o</code> 文件是十分必要的，因为它将通过 BPF skeleton 被嵌入到最后的二进制应用中，所以要避免因为不必要的 DWARF 数据增加它的大小。</p></blockquote> <p>既然我们已经生成了一个 <code>.bpf.o</code> 文件，<code>bpftool</code>可以用来生成一个对应的 BPF skeleton 头文件，即<code>.skel.h</code>，是通过<code>bpftool gen skeleton</code> 命令完成的：</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code><span class="token comment"># Generate BPF skeletons</span>
<span class="token symbol"><span class="token variable">$</span>(OUTPUT)/%.skel.h</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>/%.bpf.o <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> msg,GEN-SKEL,<span class="token variable">$@</span><span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>BPFTOOL<span class="token punctuation">)</span> gen skeleton <span class="token variable">$&lt;</span> &gt; <span class="token variable">$@</span>
</code></pre></div><p>通过这种方式，我们确保了无论何时更新 BPF skeleton，用户空间的的应用也会被更新。因为他们需要在编译时将 BPF skeleton 嵌入进去。用户空间的 <code>.c</code> → <code>.o</code> 编译则是相当直接的：</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code><span class="token comment"># Build user-space code</span>
<span class="token symbol"><span class="token variable">$</span>(patsubst %,<span class="token variable">$</span>(OUTPUT)/%.o,<span class="token variable">$</span>(APPS))</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.skel.h

<span class="token symbol"><span class="token variable">$</span>(OUTPUT)/%.o</span><span class="token punctuation">:</span> %.c <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> %.h<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> msg,CC,<span class="token variable">$@</span><span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>INCLUDES<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %.c,<span class="token variable">$^</span><span class="token punctuation">)</span> -o <span class="token variable">$@</span>
</code></pre></div><p>最后，只使用用户空间的 <code>.o</code> 文件，以及 <code>libbpf.a</code> 静态库，就生成了最终的二进制文件。<code>-lelf</code> 和 <code>-lz</code> 是 libbpf 的依赖，需要显式地提供给编译器：</p> <div class="language-makefile extra-class"><pre class="language-makefile"><code><span class="token comment"># Build application binary</span>
<span class="token symbol"><span class="token variable">$</span>(APPS)</span><span class="token punctuation">:</span> %<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>/%.o <span class="token variable">$</span><span class="token punctuation">(</span>LIBBPF_OBJ<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT<span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> msg,BINARY,<span class="token variable">$@</span><span class="token punctuation">)</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$^</span> -lelf -lz -o <span class="token variable">$@</span>
</code></pre></div><p>也就是说，在运行上面几个步骤后，你将会得到一个很小的用户空间的二进制文件。通过 BPF skeleton，编译出的 BPF 代码被嵌入到了这个二进制文件中，静态链接了 libbpf。所以它不再依赖于系统侧全局的 <code>libbpf</code>。这个二进制文件仅有 200KB，运行起来很快、可以独立执行，正如 <a href="http://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html" target="_blank" rel="noopener noreferrer">Brendan Gregg 所述<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="bootstrap-app"><a href="#bootstrap-app" class="header-anchor">#</a> Bootstrap app</h2> <p>我们已经介绍了 <code>minimal</code> 应用是什么样的，以及是如何编译的，下面我们就看看 <code>bootstrap</code> 中显示出的别的 BPF 特性。 <code>bootstrap</code> 是我之前写到的，是一个适用于生产环境下的 BPF 应用、它依赖于 BPF CO-RE (read why <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/" target="_blank" rel="noopener noreferrer">here<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) 特性，需要 Linux 内核在编译时选择 <code>CONFIG_DEBUG_INFO_BTF=y</code> (see <a href="https://github.com/libbpf/libbpf#bpf-co-re-compile-once--run-everywhere" target="_blank" rel="noopener noreferrer">here<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)。</p> <p><code>bootstrap</code> 追踪的是 <code>exec()</code> 系统调用，使用的是 <code>SEC(&quot;tp/sched/sched_process_exec&quot;) handle_exit</code> BPF 程序，大致上和进程的创建有关（这里忽略掉 <code>fork()</code>）。另外，它追踪了 <code>exit()</code> 调用，这个是用的 <code>SEC(&quot;tp/sched/sched_process_exit&quot;) handle_exit</code> BPF 程序，来监控每个进程是何时结束的。这两个 BPF 程序，共同协作，允许捕获到每个新建进程的信息，例如二进制文件名，每个进程的生命周期，收集进程消亡时的数据信息，如 exit code 或消耗的资源等。如果你想要看看内核到底在干嘛，它会是一个很好的开始。</p> <p><code>bootstrap</code> 也用了libc 的部分 <a href="https://www.gnu.org/software/libc/manual/html_node/Argp.html" target="_blank" rel="noopener noreferrer">argp API<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>  来解析命令行参数，可以参考 <a href="http://download.savannah.nongnu.org/releases-noredirect/argpbook/step-by-step-into-argp.pdf" target="_blank" rel="noopener noreferrer">&quot;Step-by-Step into Argp&quot; tutorial<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来了解这个 库是咋用的。用它我们提供了一些选项给程序，比如可以解析生命周期时长参数，即下面的<code>min_duration_ns</code> 只读变量。使用命令 <code>sudo ./bootstrap -d 100</code> 来显示最近 100 ms 存活的进程。详细的模式可以用 <code>sudo ./bootstrap -v</code>，激活 <code>libbpf</code> 调试信息。</p> <h3 id="includes-vmlinux-h-libbpf-and-app-headers"><a href="#includes-vmlinux-h-libbpf-and-app-headers" class="header-anchor">#</a> Includes: vmlinux.h, libbpf and app headers</h3> <p>下面是 <a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/src/bootstrap.bpf.c" target="_blank" rel="noopener noreferrer">bootstrap.bpf.c<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 导入的头文件：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;vmlinux.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bpf/bpf_helpers.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bpf/bpf_tracing.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bpf/bpf_core_read.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;bootstrap.h&quot;</span></span>
</code></pre></div><p>和 <code>minimal.bpf.c</code> 不同的是，我们使用了 <code>vmlinux.h</code> 头文件，在一个文件中包含了内核中所有的类型。他是 libbpf-bootstrap 项目里 <a href="https://raw.githubusercontent.com/libbpf/libbpf-bootstrap/master/src/vmlinux_508.h" target="_blank" rel="noopener noreferrer">预先生成的<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，但是开发者也可以自己使用 <code>bpftool</code> 来生成，具体可以参考 <a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/tools/gen_vmlinux_h.sh" target="_blank" rel="noopener noreferrer">gen_vmlinux_h.sh<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <blockquote><p><code>vmlinux.h</code> 中所有的类型都会携带着额外的标签 <code>__attribute__((preserve_access_index))</code>，它会让 Clang 生成具有 <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/#reading-kernel-structure-s-fields" target="_blank" rel="noopener noreferrer">BPF CO-RE relocations<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>,的程序，允许 libbpf 将你的 BPF 代码放到宿主机内核内存的特定位置，即使它和脚手架项目最初生成的那个 <code>vmlinux.h</code> 不同。这是构建可迁移的预编译出的 BPF 应用很关键的一步，从而不需要将整个 Clang/LLVM 工具链部署到目标系统上。与之相对的是 BCC 的方法，在运行时编译 BPF 代码，有很多<a href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/#why-libbpf-and-bpf-co-re" target="_blank" rel="noopener noreferrer">弊端<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p><code>vmlinux.h</code> 不能和其他系统侧的内核头文件结合，显然，若是那么干了，你将会碰到重复定义的问题。所以只使用 libbpf 提供的 <code>vmlinux.h</code> 头文件就好了。</p></div> <p>除了 <code>bpf_helpers.h</code>，我们也使用了一些其他的 libbpf 提供的头文件，如<code>bpf_tracing.h</code> 和 <code>bpf_core_read.h</code>，提供了一些额外的宏来写具有 CO-RE 特性的 BPF 应用。最后，<code>bootstrap.h</code> 包含了通用的类型定义，在 BPF 和用户空间的代码之间共享。</p> <h3 id="bpf-maps"><a href="#bpf-maps" class="header-anchor">#</a> BPF maps</h3> <blockquote><p><code>bootstrap</code> 展示了 BPF maps 的使用方法，它是 BPF 中的抽象数据结构。许多不同的数据结构都可以被建模为 BPF maps：例如数组、哈希表、per-socket 和 per-task 的本地存储、BPF perf  和 ring buffers，甚至是其他奇特的用法。重要的是大多数 BPF maps 允许执行差序、更新、按照键删除元素等方法。一些 BPF maps 允许额外的操作，比如 <a href="https://nakryiko.com/posts/bpf-ringbuf/" target="_blank" rel="noopener noreferrer">BPF ring buffer<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，允许数据入队，但是用于都不从 BPF 侧删除它。BPF maps 是用来在 BPF 程序和用户空间之间共享状态的。另一个起到这种作用的是 BPF 全局变量，它在底层也是用 BPF maps 实现的。</p></blockquote> <p>在 <code>bootstrap</code> 中，我们定义了名叫 BPF map 的 <code>exec_start</code> 的 <code>BPF_MAP_TYPE_HASH</code> 类型的哈希表。它最大容纳 8192 个元素，键是 <code>pid_t</code> 类型的，值是一个 64 位的无符号整型，存储了进程运行事件的纳秒粒度的时间戳。这就是所谓的 BTF-defined map，<code>SEC(&quot;.maps&quot;)</code> 标注是必要的，让 libbpf 知晓它需要在内核中创建对应的 BPF map，在 BPF 代码中：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token function">__uint</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> BPF_MAP_TYPE_HASH<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">__uint</span><span class="token punctuation">(</span>max_entries<span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">__type</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">pid_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">__type</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> u64<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> exec_start <span class="token function">SEC</span><span class="token punctuation">(</span><span class="token string">&quot;.maps&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这样一个哈希表中添加、更新元素是很简单的：</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	u64 ts<span class="token punctuation">;</span>

	<span class="token comment">/* remember time exec() was executed for this PID */</span>
	pid <span class="token operator">=</span> <span class="token function">bpf_get_current_pid_tgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">;</span>
	ts <span class="token operator">=</span> <span class="token function">bpf_ktime_get_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">bpf_map_update_elem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exec_start<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ts<span class="token punctuation">,</span> BPF_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>bpf_map_update_elem()</code> BPF helper 接收 map 它自己的指针、键和值的指针，在这个例子中 <code>BPF_ANY</code> 表示的是或者添加一个新的键或者更新已有的键值对。</p> <p>注意第二个 BPF 程序（<code>handle_exit</code>）从同一个 BPF map 中查询元素，之后删除它。它展示了 <code>exec_start</code> map 是在两个 BPF 程序之间共享的：</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	u64 <span class="token operator">*</span>start_ts<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	start_ts <span class="token operator">=</span> <span class="token function">bpf_map_lookup_elem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exec_start<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>start_ts<span class="token punctuation">)</span>
		duration_ns <span class="token operator">=</span> <span class="token function">bpf_ktime_get_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token operator">*</span>start_ts<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token function">bpf_map_delete_elem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exec_start<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="read-only-bpf-configuration-variables"><a href="#read-only-bpf-configuration-variables" class="header-anchor">#</a> Read-only BPF configuration variables</h4> <p><code>bootstrap</code> 和 <code>minimal</code> 不同，使用的是只读的全局变量：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> min_duration_ns <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p><code>const volatile</code> 是重要的，它为 BPF 代码和用户空间的代码标记了只读变量。它具体定义了 <code>min_duration_ns</code> 的值，同时在 BPF 程序的验证期间，BPF verifier 是知晓它的。这就允许 BPF verifier 优化无效的代码，也就是这样只读的变量限制下访问不到的代码路径，即减少了不可到达的分支逻辑。这个特性在一些更加高级的用例里是很受欢迎的，例如可移植性的检查和其他配置项。</p> <blockquote><p><code>volatile</code> 是让 Clang 不去优化掉该变量、忽略掉用户空间所提供的值所必要的。否则，Clang 可以自由地移除掉该变量，这不是我们想要的结果。</p></blockquote> <p>在用户侧代码 <a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/src/bootstrap.c" target="_blank" rel="noopener noreferrer">bootstrap.c<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中，初始化自由的只读全局变量是有一点点不太一样的。他们需要在 BPF skeleton 被加载到内核前就设置好。所以，不能直接使用一个单步的 <code>bootstrap_bpf__open_and_load()</code>。我们需要先使用 <code>bootstrap_bpf__open()</code> 来创建 skeleton，然后设置只读变量值，再调用 <code>bootstrap_bpf__load()</code> 把 skeleton 加载到内核里：</p> <div class="language-c extra-class"><pre class="language-c"><code>	<span class="token comment">/* Load and verify BPF application */</span>
	skel <span class="token operator">=</span> <span class="token function">bootstrap_bpf__open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">&quot;Failed to open and load BPF skeleton\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/* Parameterize BPF code with minimum duration parameter */</span>
	skel<span class="token operator">-&gt;</span>rodata<span class="token operator">-&gt;</span>min_duration_ns <span class="token operator">=</span> env<span class="token punctuation">.</span>min_duration_ms <span class="token operator">*</span> <span class="token number">1000000ULL</span><span class="token punctuation">;</span>

	<span class="token comment">/* Load &amp; verify BPF programs */</span>
	err <span class="token operator">=</span> <span class="token function">bootstrap_bpf__load</span><span class="token punctuation">(</span>skel<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">&quot;Failed to load and verify BPF skeleton\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>注意只读变量是 skeleton 中 <code>rodata</code> 段的一部分，不是 <code>data</code> 或 <code>bss</code> 段，所以是这么取它的： <code>skel-&gt;rodata-&gt;min_duration_ns</code>。在 BPF skeleton 被加载后，用户空间的的代码只能读取只读变量的值。BPF 代码也只能阅读这些变量。 一旦检测到写只读变量的操作，BPF verifier 将会拒绝 BPF 程序。</p> <h3 id="bpf-ring-buffer"><a href="#bpf-ring-buffer" class="header-anchor">#</a> BPF ring buffer</h3> <p><code>bootstrap</code> 大量地使用了 BPF ring buffer map 来准备和发送数据到用户空间。它使用了 <code>bpf_ringbuf_reserve()</code>/<code>bpf_ringbuf_submit()</code> <a href="https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-reserve-commit-api" target="_blank" rel="noopener noreferrer">combo<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 以获得最佳的可用性和性能，可以阅读 <a href="https://nakryiko.com/posts/bpf-ringbuf/" target="_blank" rel="noopener noreferrer">BPF ring buffer 相关博客<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来深入理解。那篇文章深入探究了相似的内容，解读了另一个独立的分支 <a href="https://github.com/libbpf/bpf-ringbuf-examples/" target="_blank" rel="noopener noreferrer">bpf-ringbuf-examples<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的例子。它会给你一个很好的例子，帮助你了解如何使用 BPF perf buffer。</p> <h3 id="bpf-co-re"><a href="#bpf-co-re" class="header-anchor">#</a> BPF CO-RE</h3> <p>BPF CO-RE (Compile Once – Run Everywhere) 是一个很大的话题， <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/" target="_blank" rel="noopener noreferrer">另有一篇博客<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 详细描述了它，可以参阅它去理解。这里有一个来自 <code>bootstrap.bpf.c</code> 中的例子，利用了 BPF CO-RE 特性来从内核的结构体 <code>struct task_struct</code> 中读取数据：</p> <div class="language-c extra-class"><pre class="language-c"><code>	e<span class="token operator">-&gt;</span>ppid <span class="token operator">=</span> <span class="token function">BPF_CORE_READ</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> real_parent<span class="token punctuation">,</span> tgid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在非 BPF 的世界中，可以很简单地写作 <code>e-&gt;ppid = task-&gt;real_parent-&gt;tgid;</code>，但是 BPF verifier 需要付出额外的努力，因为任意地去内核内存是存在风险的。 <code>BPF_CORE_READ()</code> 就用了一个简洁的方式处理这个问题，它在读取指针对应位置的过程中，记录了 BPF CO-RE 重定位带来的地址偏移，允许 libbpf 将所有字段偏移量调整到宿主机器内核的特定内存布局上。可以参考 <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/#reading-kernel-structure-s-fields" target="_blank" rel="noopener noreferrer">这篇博客<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来深入了解。</p> <h2 id="conclusion"><a href="#conclusion" class="header-anchor">#</a> Conclusion</h2> <p>这篇文章大概囊括了 <code>libbpf-bootstrap</code> 和 BPF/libbpf 的方方面面。希望 <code>libbpf-bootstrap</code> 让你度过 BPF 开发的起步阶段，避免配置环境的痛苦，让你的时间更多地用在 BPF 本身上。对于更有经验的 BPF 开发者，这篇文章应该已经揭示了 BPF 在可用性方面的提升，如 BPF skeleton、BPF ringbuf、BPF CO-RE，以防你没有紧密地追踪 BPF 的最新进展。</p> <h2 id="补充-bpf-map-相关内容"><a href="#补充-bpf-map-相关内容" class="header-anchor">#</a> 补充 BPF Map 相关内容</h2> <p>该部分内容来自本博客之前引用过的一篇文章，<a href="https://blog.csdn.net/sinat_38816924/article/details/115607570" target="_blank" rel="noopener noreferrer">原文链接<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。作者是阅读了 <a href="https://www.oreilly.com/library/view/linux-observability-with/9781492050193/" target="_blank" rel="noopener noreferrer">Linux Observability with BPF<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这本书做的笔记，这本书的电子版在 <a href="https://z-lib.org/" target="_blank" rel="noopener noreferrer">Z-Library<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 上能找到。</p> <p>消息传递来唤醒程序的行为，在软件工程中很常见。一个程序可以通过发送消息来修改另一个程序的行为；这也允许这些程序之间交换信息。关于 BPF 最吸引人的一个方面是，运行在内核上的代码和加载所述代码的用户空间程序可以在运行时使用消息传递相互通信。BPF maps 用来实现此功能。BPF maps 是驻留在内核中的键/值存储。任何知道它们的 BPF 程序都可以访问它们。在用户空间中运行的程序也可以使用文件描述符访问这些映射。只要事先正确指定数据大小，就可以在 maps 中存储任何类型的数据。</p> <h3 id="使用bpf系统调用操作-bpf-maps"><a href="#使用bpf系统调用操作-bpf-maps" class="header-anchor">#</a> 使用BPF系统调用操作 BPF maps</h3> <p>bpf 系统调用的原型如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/bpf.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">bpf</span><span class="token punctuation">(</span><span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">union</span> bpf_attr <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>例如创建一个 hash-table map。其中key和value都是无符号整形。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">union</span> bpf_attr my_map <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>map_type <span class="token operator">=</span> BPF_MAP_TYPE_HASH<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>key_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>value_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>max_entries <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>map_flags <span class="token operator">=</span> BPF_F_NO_PREALLOC<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">bpf</span><span class="token punctuation">(</span>BPF_MAP_CREATE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_map<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>my_map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="使用-bpf-helper-创建bpf-maps"><a href="#使用-bpf-helper-创建bpf-maps" class="header-anchor">#</a> 使用 BPF helper 创建BPF maps</h3> <p>helper函数bpf_map_create包装了刚才看到的代码，以便更容易根据需要初始化映射。我们可以使用它创建上一个map，只需一行代码：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> fd<span class="token punctuation">;</span>
fd <span class="token operator">=</span> <span class="token function">bpf_create_map</span><span class="token punctuation">(</span>BPF_MAP_TYPE_HASH<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span>BPF_F_NO_PREALOC<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果是将要加载到内核的代码，也可以如下这样创建map。创建原理是：<code>bpf_load.c</code> 扫描目标文件时候，解析到 maps section，会通过 bpf syscall 创建 maps。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">bpf_map_def</span> <span class="token function">SEC</span><span class="token punctuation">(</span><span class="token string">&quot;maps&quot;</span><span class="token punctuation">)</span> my_map <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>type <span class="token operator">=</span> BPF_MAP_TYPE_HASH<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>key_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>value_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>max_entries <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>map_flags <span class="token operator">=</span> BPF_F_NO_PREALLOC<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>用户空间的程序，调用 <code>load_bpf_file</code> 函数，将 <code>bpf</code> 程序加载的内核。<code>load_bpf_file</code> 会扫描 bpf 程序（elf 格式）的各个 section。对于名为 maps 的 section，<code>load_bpf_file</code> 会从中提取出maps的信息，并调用 <code>syscall(__NR_bpf, 0, attr, size);</code> 系统调用，创建map。</p> <h3 id="working-with-bfp-maps"><a href="#working-with-bfp-maps" class="header-anchor">#</a> Working with BFP Maps</h3> <p>内核和用户空间之间的通信将是您编写的每个BPF程序的一个基本部分。给内核编写代码时访问 map 的 api 与给用户空间程序编写代码不同。对于 <code>bpf_map_update_elem</code> 这个程序：运行在内核的代码从 <code>bpf_helpers.h</code> 加载；运行在用户空间的代码从<code>tools/lib/bpf/bpf.h</code> 加载；这样区分的原因是，内核空间可以直接访问 maps；而用户空间访问 maps 需要通过文件描述符。在内核上运行，可以在原子方式更新元素。在用户空间运行的代码，内核需要复制值以用于更新 map。这个非原子操作，可能失败。如果失败，失败原因填充到全局变量 errno 中。</p> <p>对于5.4内核源码 bpf_helpers.h 的位置如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">&quot;bpf_helpers.h&quot;</span>
<span class="token comment"># tools/testing/selftests/bpf/bpf_helpers.h</span>
</code></pre></div><h3 id="更新元素"><a href="#更新元素" class="header-anchor">#</a> 更新元素</h3> <p>我们先看从内核中更新map的函数。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// tools/testing/selftests/bpf/bpf_helpers.h</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>bpf_map_update_elem<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>map<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span>
				  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span> <span class="token operator">=</span>
	<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> BPF_FUNC_map_update_elem<span class="token punctuation">;</span>
<span class="token comment">// #define BPF_FUNC_map_update_elem 2</span>
</code></pre></div><p>内核中出现这些奇奇怪怪的数字很正常。我暂时不知道这个2是什么鬼。</p> <p>内核中的 bpf_map_update_elem 函数有四个参数。第一个是指向我们已经定义的 map 的指针。第二个是指向要更新的键的指针。因为内核不知道我们要更新的键的类型，所以这个方法被定义为指向 void 的不透明指针，这意味着我们可以传递任何数据。第三个参数是我们要插入的值。此参数使用与键参数相同的语义。我们在本书中展示了一些如何利用不透明指针的高级示例。您可以使用此函数中的第四个参数来更改map的更新方式。此参数可以采用三个值：</p> <p>如果传递0，则告诉内核如果元素存在，则要更新该元素；如果元素不存在，则要在映射中创建该元素。[0 可以用 BPF_ANY 宏表示]
如果传递1，则告诉内核仅在元素不存在时创建该元素。[1 可以用 BPF_NOEXIST 宏表示]
如果传递2，内核将只在元素存在时更新它。[2 可以用 BPF_EXIST 宏表示]</p> <p>也可以从用户空间程序中更新 map。执行此操作的帮助程序与我们刚才看到的类似；唯一的区别是，它们使用文件描述符访问 map，而不是直接使用指向 map 的指针。正如您所记得的，用户空间程序总是使用文件描述符访问 map。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// tools/lib/bpf/bpf.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LIBBPF_API</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIBBPF_API</span> <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span><span class="token punctuation">(</span></span><span class="token string">&quot;default&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
LIBBPF_API <span class="token keyword">int</span> <span class="token function">bpf_map_update_elem</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span>
				   __u64 flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里的fd获取方式有两种。第一中，是使用 bpf_create_map 函数返回的 fd。也可以通过全局变量 map_fd 访问。</p> <h3 id="读取元素"><a href="#读取元素" class="header-anchor">#</a> 读取元素</h3> <p><code>bpf_map_lookup_elem</code>：从 map 中读取内容。同样，也分为内核空间和用户空间两种形式。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 内核空间</span>
<span class="token comment">// tools/testing/selftests/bpf/bpf_helpers.h</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>bpf_map_lookup_elem<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>map<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token operator">=</span>
	<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> BPF_FUNC_map_lookup_elem<span class="token punctuation">;</span>
<span class="token comment">//#define BPF_FUNC_map_lookup_elem 1</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 用户空间</span>
<span class="token comment">// tools/lib/bpf/bpf.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LIBBPF_API</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIBBPF_API</span> <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span><span class="token punctuation">(</span></span><span class="token string">&quot;default&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
LIBBPF_API <span class="token keyword">int</span> <span class="token function">bpf_map_lookup_elem</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它们的第一个参数也有所不同；内核方法引用映射，而用户空间帮助程序将映射的文件描述符标识符作为其第一个参数。第三个参数是指向代码中要存储从映射中读取的值的变量的指针。</p> <h3 id="删除元素"><a href="#删除元素" class="header-anchor">#</a> 删除元素</h3> <p>同样有两种：运行在用户空间，运行在内核空间。如果删除的 key 不存在，返回一个负数；error 被设置成 ENOENT。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>bpf_map_delete_elem<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>map<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token operator">=</span>
	<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> BPF_FUNC_map_delete_elem<span class="token punctuation">;</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code>LIBBPF_API <span class="token keyword">int</span> <span class="token function">bpf_map_delete_elem</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="迭代遍历元素"><a href="#迭代遍历元素" class="header-anchor">#</a> 迭代遍历元素</h3> <p>bpf_map_get_next_key，此指令仅适用于在用户空间上运行的程序。</p> <div class="language-c extra-class"><pre class="language-c"><code>LIBBPF_API <span class="token keyword">int</span> <span class="token function">bpf_map_get_next_key</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>next_key<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>第一个参数：map 的文件描述符。第二个参数：lookup_key，你希望查找的属性值对应的 key。第三个参数：next_key，map 中的 next key。</p> <p>当您调用这个帮助程序时，BPF 会尝试在这个 map 中找到作为查找键传递的键的元素；然后，它会用映射中相邻的键设置下一个next_key 参数。因此，如果您想知道哪个键在键 1 之后，您需要将 1 设置为 lookup_key，BPF 会将与之相邻的 key 设置为下一个next_key 参数的值。</p> <p>如果要打印映射中的所有值，可以使用 bpf_map_get_next_key 键和映射中不存在的查找键。这将强制 BPF 从地图的开头开始。</p> <p>当 bpf_map_get_next_key 到达 map 的末尾时候，返回一个负数，errno 值被设置成 ENOENT。</p> <p>您可以想象，bpf_map_get_next_key 可以从地图中的任何一点开始查找 key；如果您只希望另一个特定 key 的下一个 key，则不需要从map 的开头开始。</p> <p>另外，我们还需要知道 bpf_map_get_next_key 的另一个行为。许多编程语言会在迭代遍历之前，复制 map。因为遍历的时候，如果有代码删除将要遍历的元素，将会很危险。bpf_map_get_next_key 遍历的时候，没有复制 map。如果遍历的时候，map 中存在元素被删除，bpf_map_get_next_key 会自动跳过它。</p> <h3 id="查找删除元素"><a href="#查找删除元素" class="header-anchor">#</a> 查找删除元素</h3> <p>bpf_map_lookup_and_delete_elem：一个元素通过 key 进行搜索。搜索到之后，删除这个元素，同时将元素的值放在 value 中。这个也是仅仅适用于用户空间。</p> <div class="language-c extra-class"><pre class="language-c"><code>LIBBPF_API <span class="token keyword">int</span> <span class="token function">bpf_map_lookup_and_delete_elem</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="并发访问-map"><a href="#并发访问-map" class="header-anchor">#</a> 并发访问 map</h3> <p>使用 BPF 映射的挑战之一是许多程序可以同时访问相同的映射。这会在我们的 BPF 程序中引入竞争条件。为了防止竞争情况，BPF 引入了 BPF 自旋锁的概念，它允许您在对 map 元素进行操作时锁定对 map 元素的访问。自旋锁仅适用于 array、hash 和 cgroup 存 maps。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 信号量</span>
<span class="token comment">// /usr/include/linux</span>
<span class="token keyword">struct</span> <span class="token class-name">bpf_spin_lock</span> <span class="token punctuation">{</span>
	__u32	val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 内核</span>
<span class="token comment">// 加锁+解锁</span>
<span class="token comment">// tools/testing/selftests/bpf/bpf_helpers.h</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>bpf_spin_lock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bpf_spin_lock</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token operator">=</span>
	<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> BPF_FUNC_spin_lock<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>bpf_spin_unlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bpf_spin_lock</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token operator">=</span>
	<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> BPF_FUNC_spin_unlock<span class="token punctuation">;</span>
</code></pre></div><p>我这里复制下书上的事例。这个访问控制，精度比较细。对每一个元素使用了自旋锁。另外这个 map 必须用 BPF 类型格式（BPF Type Format, BTF）注释，这样 verifier 就知道如何解释这个结构。类型格式通过向二进制对象添加调试信息，使内核和其他工具对BPF数据结构有了更丰富的理解。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">concurrent_element</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">bpf_spin_lock</span> semaphore<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">bpf_map_def</span> <span class="token function">SEC</span><span class="token punctuation">(</span><span class="token string">&quot;maps&quot;</span><span class="token punctuation">)</span> concurrent_map <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>type <span class="token operator">=</span> BPF_MAP_TYPE_HASH<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>key_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>value_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">concurrent_element</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>max_entries <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">BPF_ANNOTATE_KV_PAIR</span><span class="token punctuation">(</span>concurrent_map<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">concurrent_element</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">bpf_program</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">concurrent_element</span> init_value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">concurrent_element</span> <span class="token operator">*</span>read_value<span class="token punctuation">;</span>
    <span class="token function">bpf_map_create_elem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>concurrent_map<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>init_value<span class="token punctuation">,</span> BPF_NOEXIST<span class="token punctuation">)</span><span class="token punctuation">;</span>
    read_value <span class="token operator">=</span> <span class="token function">bpf_map_lookup_elem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>concurrent_map<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bpf_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_value<span class="token operator">-&gt;</span>semaphore<span class="token punctuation">)</span><span class="token punctuation">;</span>
    read_value<span class="token operator">-&gt;</span>count <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token function">bpf_spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_value<span class="token operator">-&gt;</span>semaphore<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>用户空间更改 map 的话，使用 <code>bpf_map_update_elem</code> 和 <code>bpf_map_lookup_elem_flags</code> 的时候，添加 <code>BPF_F_LOCK</code> flags。</p> <div class="gitalk-container"><div id="gitalk-container"></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/12/28 下午12:12:57</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.8a71fa9b.js" defer></script><script src="/assets/js/1.0d3f5407.js" defer></script><script src="/assets/js/69.38117192.js" defer></script><script src="/assets/js/13.0b8f69bf.js" defer></script>
  </body>
</html>
